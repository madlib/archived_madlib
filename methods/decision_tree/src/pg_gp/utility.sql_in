/**
 * @brief Convert bigint to char
 * @param val Bigint value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    ) 
RETURNS TEXT AS $$
DECLARE 
    result TEXT := '';
    toCharBase TEXT := '999999999';
BEGIN
    SELECT to_char(val, toCharBase) INTO result;
    SELECT trim(both ' ' from result) INTO result;
    
    return result;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Convert float to char
 * @param val float value
 */
 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    return val || '';
END
$$ LANGUAGE plpgsql;


/**
 * @brief Convert boolean to char
 * @param val boolean value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    IF (val) THEN
        return 't';
    ELSE
        return 'f';
    END IF;
END
$$ LANGUAGE plpgsql;

/**
 * @brief Format a string with the value in allValues array
 * @param formatStr the format string
 * @param allValues the specified elements in formatStr
 *
 * @note All the char ('%') in formatStr will be replaced with allValues
 *       The number of '%' should be equal with the length of array allValues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    allValues TEXT[]
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    allValues TEXT[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
    parts TEXT[];
    idx INT := 1;
    curPart TEXT;
    curValue TEXT;
BEGIN
    SELECT regexp_split_to_array(formatStr, '%') INTO parts;
    
    LOOP
        curPart = parts[idx];
        curValue = allValues[idx];
        IF (curPart IS NULL OR curValue IS NULL ) THEN
            EXIT;
        END IF;
        
        stmt = stmt || curPart || curValue;
        idx = idx + 1;
    END LOOP;
    
    IF (curPart IS NOT NULL) THEN
        stmt = stmt || curPart;
    END IF;
    return stmt;
END
$$ LANGUAGE plpgsql;

/**
 * @brief Short form to format a string with four parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 * @param value4 The fouth value
    
 * @note All the char ('%') in formatStr will be replaced with allValues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT, 
    value3 TEXT,
    value4 TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT, 
    value3 TEXT,
    value4 TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(formatStr, ARRAY[value1, value2, value3, value4]) INTO stmt;
    return stmt;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Short form to format a string with three parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 *
 * @note All the char ('%') in formatStr will be replaced with allValues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT, 
    value3 TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT, 
    value3 TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(formatStr, ARRAY[value1, value2, value3]) INTO stmt;
    return stmt;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Short form to format a string with two parameters
 * @param value1 The first value
 * @param value2 The second value
 *
 * @note All the char ('%') in formatStr will be replaced with allValues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT, 
    value2 TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(formatStr, ARRAY[value1, value2]) INTO stmt;
    return stmt;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Short form to format a string with a parameter
 * @param value1 The first value
 *
 * @note All the char ('%') in formatStr will be replaced with allValues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    value1 TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(formatStr, ARRAY[value1]) INTO stmt;
    return stmt;
END
$$ LANGUAGE plpgsql;


/**
 * @brief   Format a string with the value in allValues array
 *          All the char ('%') in formatStr will be replaced with allValues
 *          If a element in quotes is t, then the value in allValues will be quoted.
 *          Such as, allValues: ['1', '2'], and quotes: ['f', 't']
 *          then allValues will be change to [''1'', ''2''] 
 *
 * @param formatStr the format string
 * @param allValues the specified elements in formatStr
 * @param quotes specify which string in the array should add quote
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    allValues TEXT[], 
    quotes BOOLEAN[]
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    formatStr TEXT, 
    allValues TEXT[], 
    quotes BOOLEAN[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
    allValues2 TEXT[];
    idx INT := 1;
    quote TEXT;
BEGIN
    LOOP
        quote = quotes[idx];
        IF (quote IS NULL) THEN
            EXIT;
        END IF;
        stmt = allValues[idx];
        IF (quote) THEN
            SELECT quote_literal( allValues[idx] )
                    INTO stmt;
        END IF;
        
        allValues2[idx] = stmt;
        idx = idx + 1;
    END LOOP;
    
    SELECT MADLIB_SCHEMA.__format(formatStr, allValues2) INTO stmt;
    return stmt;
END
$$ LANGUAGE plpgsql;


/**
 * @brief assert function
 * @param condition the assert condition
 * @param reason the reason string, will be display when assert is failed
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.assert
    (
    condition BOOLEAN,
    reason TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.assert
    (
    condition BOOLEAN,
    reason TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE plpgsql;

/**
 * @brief Test if the specified table under the specified schema exists or not
 * @param schemaName schema name of the table
 * @param tableName the short table name without schema name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__table_exists
    (
    schemaName TEXT,
    tableName TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    schemaName TEXT,
    tableName TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curStmt TEXT := '';
    result INT := 0;
    m_schemaName TEXT := '';
    m_tableName TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.assert(schemaName IS NOT NULL, 'Schema name must not be null!');
    PERFORM MADLIB_SCHEMA.assert(tableName IS NOT NULL, 'Table name must not be null!');
    
    IF(length(btrim(lower(schemaName), ' ')) = 0) THEN
        m_schemaName = 'public';
    ELSE
        m_schemaName = schemaName;
    END IF;
    
    m_tableName = btrim(lower(tableName), ' ');
    
    SELECT MADLIB_SCHEMA.__format('SELECT count(c.oid)
        FROM pg_catalog.pg_class c
        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE btrim(c.relname, '' '') = ''%''
        AND btrim(n.nspname, '' '') = ''%'';',
        m_tableName,
        m_schemaName
        )
        INTO curStmt;
    
    --RAISE INFO 'statement:%', curStmt;
    
    EXECUTE curStmt INTO result;
    
    return result >= 1;
END
$$ LANGUAGE plpgsql;


/**
 * @brief assert if the specified table under the specified schema exists or not
 * @param schemaName schema name of the table
 * @param tableName the short table name without schema name
 * @param isExistence ture if assert table exists, otherwise false
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert_table
    (
    schemaName TEXT,
    tableName TEXT,
    isExistence BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert_table
    (
    schemaName TEXT,
    tableName TEXT,
    isExistence BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
BEGIN
    PERFORM MADLIB_SCHEMA.assert(MADLIB_SCHEMA.__table_exists(schemaName, tableName) = isExistence, 'assert failed!');
END
$$ LANGUAGE plpgsql;


/**
 * @brief get the meta table name by the tree table name
 * @param tree_table tree table name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_conversion_metatable_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_conversion_metatable_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
declare
    metatable_name TEXT := '';
begin
    SELECT training_meta_table_name from MADLIB_SCHEMA.training_info where tree_table_name = tree_table INTO metatable_name;
    return metatable_name;
end
$$ LANGUAGE plpgsql;


/**
 * @brief get the sparse vector table name by tree table name
 * @param tree_table tree table name
 * 
 * @return the sparse vector table name
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_conversion_svec_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_conversion_svec_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
declare
    svec_name TEXT := '';
begin
    SELECT training_svec_table_name from MADLIB_SCHEMA.training_info where tree_table_name = tree_table INTO svec_name;
    return svec_name;
end
$$ LANGUAGE plpgsql;


/**
 * @brief get the unknown values processing routine id 
 * @param tree_table tree table name         
 *  
 * @return 't' means sparse vector input. 'f' means tabular input 
 * @note currently, we only support 'ignore' or 'explicity'
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_unknown_routine_id
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_unknown_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
declare
    id INT;
    name TEXT;
begin
    SELECT unknown_routine_name from MADLIB_SCHEMA.training_info 
        where tree_table_name = tree_table INTO name;
    
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSE
        RETURN 2;
    END IF;
    
end
$$ LANGUAGE plpgsql;

/**
 * @brief get the input table format 
 * @param tree_table tree table name         
 *  
 * @return 't' means sparse vector input. 'f' means tabular input 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_input_format
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_input_format
    (
    tree_table TEXT 
    ) 
RETURNS boolean AS $$
declare
    input_format boolean := 't';
begin
    SELECT is_svec_format from MADLIB_SCHEMA.training_info 
        where tree_table_name = tree_table INTO input_format;
    return input_format;
end
$$ LANGUAGE plpgsql;

/**
 * @brief get the name of column containing ID
 * @param tree_table tree table name         
 *  
 * @return the name of column containing ID
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_id_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_id_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
declare
    id_name TEXT;
begin
    SELECT id_col_name from MADLIB_SCHEMA.training_info 
        where tree_table_name = tree_table INTO id_name;
    RETURN id_name;
end
$$ LANGUAGE plpgsql;

/**
 * @brief get the name of column containing feature
 * @param tree_table tree table name         
 *  
 * @return the name of column containing feature
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
declare
    feature_name TEXT;
begin
    SELECT feature_col_names from MADLIB_SCHEMA.training_info 
        where tree_table_name = tree_table INTO feature_name;
    RETURN feature_name;
end
$$ LANGUAGE plpgsql;

/**
 * @brief get the name of column containing class
 * @param tree_table tree table name         
 *  
 * @return the name of column containing class
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
declare
    class_name TEXT;
begin
    SELECT class_col_name from MADLIB_SCHEMA.training_info 
        where tree_table_name = tree_table INTO class_name;
    RETURN class_name;
end
$$ LANGUAGE plpgsql;

/**
 * @brief create the training info table 
 *  
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_global_metatable
    (
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_global_metatable
    (
    ) 
RETURNS void AS $$
begin
    IF ( NOT MADLIB_SCHEMA.__table_exists('MADLIB_SCHEMA', 'training_info') )THEN
        CREATE TABLE MADLIB_SCHEMA.training_info(
            tree_table_name TEXT NOT NULL,
            training_table_name TEXT,
            id_col_name TEXT,
            feature_col_names TEXT,
            class_col_name TEXT,
            is_svec_format boolean,
            training_meta_table_name TEXT,
            training_svec_table_name TEXT,
            continuous_feature_names TEXT,
            validation_table_name TEXT,
            unknown_routine_name TEXT,
            PRIMARY KEY (tree_table_name)
        ) m4_ifdef(`GREENPLUM',`DISTRIBUTED BY (tree_table_name)');
    END IF;
end
$$ LANGUAGE plpgsql;


/**
 * @brief   Remove the trained tree from training info table 
 * @param tree_table tree table name 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__remove_record_from_global_metatable
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__remove_record_from_global_metatable
    (
    tree_table TEXT 
    ) 
RETURNS void AS $$
begin
    delete from MADLIB_SCHEMA.training_info where tree_table_name = tree_table;
end
$$ LANGUAGE plpgsql;


/**
 * @brief   insert the trained tree into training info table 
 * @param result_tree_table_name tree table name
 * @param training_table_name training table name
 * @param id_col_name name of id column
 * @param feature_col_names name of feature column
 * @param class_col_name name of class column
 * @param is_svec_format the training table is sparse vector table format or not
 * @param training_meta_table_name name of training data table
 * @param training_svec_table_name name of sparse vector table 
 * @param continuous_feature_names the continuous feature names, with comma as delimiter
 * @param validation_table_name validation table name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_record_to_global_metatable
    (
          result_tree_table_name TEXT,
          training_table_name TEXT,
          id_col_name TEXT,
          feature_col_names TEXT,
          class_col_name TEXT,
          is_svec_format boolean,
          training_meta_table_name TEXT,
          training_svec_table_name TEXT,
          continuous_feature_names TEXT,
          validation_table_name TEXT,
          unknown_routine_name TEXT  
    );
               
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_record_to_global_metatable
    (
          result_tree_table_name TEXT,
          training_table_name TEXT,
          id_col_name TEXT,
          feature_col_names TEXT,
          class_col_name TEXT,
          is_svec_format boolean,
          training_meta_table_name TEXT,
          training_svec_table_name TEXT,
          continuous_feature_names TEXT,
          validation_table_name TEXT,
          unknown_routine_name TEXT   
    ) 
RETURNS void AS $$
begin
    INSERT INTO MADLIB_SCHEMA.training_info VALUES(
                        result_tree_table_name,
                        training_table_name,
                        id_col_name,
                        feature_col_names,
                        class_col_name,
                        is_svec_format,
                        training_meta_table_name,
                        training_svec_table_name,
                        continuous_feature_names,
                        validation_table_name,
                        unknown_routine_name);
end
$$ LANGUAGE plpgsql;


/**
 * @brief   set the sparse vector table name and training data table name 
 *          in the training info table
 * @param result_tree_table_name tree table name
 * @param meta_table_name name of training data table
 * @param svec_table_name name of sparse vector table 
 *  
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__set_conversion_table_name
    (
          result_tree_table_name TEXT,
          meta_table_name TEXT,
          svec_table_name TEXT
    );        
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__set_conversion_metatable_name
    (
          result_tree_table_name TEXT,
          meta_table_name TEXT,
          svec_table_name TEXT
    ) 
RETURNS void AS $$
begin
    update MADLIB_SCHEMA.training_info set training_meta_table_name = meta_table_name,
        training_svec_table_name = svec_table_name where tree_table_name = result_tree_table_name;
end
$$ LANGUAGE plpgsql;


/**
 * @brief   Strip the schema name from the full name 
 * @param full_name the full name of table (with schema name)
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
declare
    str_val TEXT;
begin
    str_val = trim(both ' ' from split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        str_val = trim(both ' ' from full_name);
    END IF;
    return str_val;
end
$$ LANGUAGE plpgsql;

/**
 * @brief   get the schema name from a full database object name
 * @param full_name the fullname of a database object
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
declare
    str_val TEXT;
    ret_val TEXT;
begin
    str_val = trim(both ' ' from split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        ret_val = 'public';
    ELSE
        ret_val = trim(both ' ' from split_part(full_name, '.', 1));
    END IF;
    return ret_val;
end
$$ LANGUAGE plpgsql;


/**
 * @brief Drop the meta table,  
 *        Drop all the tables whose names are in 'tableName' column
 * @param table_name the meta table name
 *
 * @note the name of parameter will be add the MADLIB_SCHEMA automatically
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__drop_meta_table
    (
        table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_meta_table 
    (
        table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curStmt TEXT;
    name TEXT;
BEGIN
    IF ( table_name is NULL ) THEN
        RETURN;
    END IF;
    PERFORM MADLIB_SCHEMA.__assert_table('MADLIB_SCHEMA', table_name, 't');
    
    SELECT MADLIB_SCHEMA.__format('SELECT tableName FROM MADLIB_SCHEMA.% 
                                        WHERE tableName IS NOT NULL AND length(trim(tableName, '' '')) > 1',
                                     table_name)
        INTO curStmt;
        
    FOR name IN EXECUTE curStmt LOOP
        EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || table_name || ' CASCADE;';
end
$$ LANGUAGE plpgsql;


/**
 * @brief Create meta table 
 * @param tableName the meta table name  
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_meta_table
    (
        tableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_meta_table 
    (
        tableName TEXT
    )
RETURNS void AS $$
DECLARE
    curStmt TEXT;
    result INT := 0;
BEGIN
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert_table('MADLIB_SCHEMA', tableName, 'f');
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    EXECUTE 'CREATE TABLE MADLIB_SCHEMA.'|| tableName || E'(
        id SERIAL,
        columnName TEXT,
        columnType CHAR,    
        isCont BOOLEAN,     
        tableName TEXT,
        numOfDistValue INT
    ) m4_ifdef(\`GREENPLUM\',\`DISTRIBUTED BY (id)\');';
    
END
$$ LANGUAGE plpgsql;

/**
 * @brief Get the continuous feature split values for specified selection
 * @param splitVals the split values for all the continuous features
 * @param selection the id of continuous feature  
 *
 * @return the float8 array of split values for the specified selection
 * @example
 *      [2,1,3,2,5,split values for feature 1, split value for featue 2, ...]
 *      The 1st value of array is the number of continuous values
 *      The 2nd value of array is the continuous feature id
 *      The 3rd value of array is the number of split values of the feature 2nd
 *      The 4th value of array is the continuous feature id
 *      The 5th value of array is the number of split values of the feature 4th
 *      After that, following the split values list in the header of array 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_cont_feature_selection_split
    (
        splitVals TEXT,
        selection INT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_cont_feature_selection_split 
    (
        splitVals TEXT,
        selection INT
    )
RETURNS FLOAT8[] AS $$
DECLARE
  result float8[];
  selValue TEXT;
BEGIN
    IF (splitVals <> 'null') THEN
        --RAISE INFO 'split part: %, selection: %', splitVals, selection;
        selValue = split_part(splitVals, '|', selection);
        
        EXECUTE 'SELECT CAST(' || quote_literal(selValue) || ' as float8[])' INTO result;
        return result;
    end if;
    
    return NULL;
    
END
$$ LANGUAGE plpgsql;


/**
 * @brief Get all the continuous feature split values, the delimiter is '|'
 * @param selected_table_name the weighted instances table with selection
 * @param meta_table_name meta table name contains all the features's data
 *                        such as is continuous or not, the distinct values  
 * @param selection_cnt the number of distinct selection in the weighted instances
 * @param selection_cnt the minimum selection in the weighted instances
 *
 * @return a text with delimiter '|' for all the continuous features' split value
 *         null means the weighted instances table doesn't contain any continuous feature
 *  
 */ 
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_cont_feature_split_vals
    (
        selected_table_name TEXT,
        meta_table_name TEXT,
        selection_cnt INT,
        selection_begin INT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_cont_feature_split_vals 
    (
        selected_table_name TEXT,
        meta_table_name TEXT,
        selection_cnt INT,
        selection_begin INT
    )
RETURNS TEXT AS $$
DECLARE
    curStmt TEXT := '';
    id_num INT;
    valueRec RECORD;
    splitValue FLOAT := 0.0;
    valueStmt TEXT := '';
    iCont INT := 0;
    result TEXT := '';
    tempStmt TEXT := '';
    resultArray TEXT[];
    valueArray TEXT[];
    iSplit INT[];
    selIdx INT := 1;
    curSel INT := 1;
BEGIN
          
    --RAISE INFO 'selection cnt: %', selection_cnt;
    FOR selIdx IN 1..selection_cnt LOOP
        resultArray[selIdx] = '';
        valueArray[selIdx] = '';
        iSplit[selIdx] = 0;
    END LOOP;
    
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT id  FROM % WHERE is_continuous = ''t'' ORDER BY id;',
            meta_table_name
        ) 
        INTO curStmt; 
    FOR id_num IN EXECUTE (curStmt) LOOP
        -- MADLIB_SCHEMA.__to_char(sample_limit)
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT selection, (p.contVal + lag(p.contVal) OVER (partition by selection ORDER BY p.contVal)) / 2 as splitValue 
                 FROM
                    (
                        SELECT DISTINCT selection, MADLIB_SCHEMA.svec_proj(w.feature, %) as contVal  
                        FROM % w 
                        ORDER BY selection, contVal  
                     )  p where (p.contVal is not null) AND (p.contVal <> ''NAN'') ORDER BY selection',
                 MADLIB_SCHEMA.__to_char(id_num),
                 selected_table_name
             )
             INTO tempStmt;
         
         FOR valueRec IN EXECUTE (tempStmt) LOOP
            splitValue = valueRec.splitValue;
            IF (splitValue IS NOT NULL ) THEN
                --RAISE INFO 'sel:%, begin:%, cnt: %, value:%', valueRec.selection, selection_begin, selection_cnt, splitValue;
                selIdx = valueRec.selection - selection_begin + 1;
                resultArray[selIdx] = resultArray[selIdx] || ',' || splitValue;
                iSplit[selIdx] = iSplit[selIdx] + 1;
            END IF;
         END LOOP;
         
         FOR selIdx IN 1..selection_cnt LOOP
                valueArray[selIdx] = valueArray[selIdx] ||  ',' || id_num || ',' || iSplit[selIdx];
                iSplit[selIdx] = 0;
         END LOOP;
         
         iCont = iCont + 1;
    END LOOP;      
    
    result = '';
    
    IF (iCont >= 1) THEN
        FOR selIdx IN 1..selection_cnt LOOP
            result = result || '{' || iCont || valueArray[selIdx] || resultArray[selIdx] || '}|';
        END LOOP;
        --RAISE INFO 'split values:%', result;
        return result;
    END IF;
    
    return 'null';
    
END
$$ LANGUAGE plpgsql;

/**
 * @brief Get an array with text format
 * @param metaTableName name of training data table
 *  
 * @return  an array with text format, which contains the number of each feature's distinct values
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_count_array
    (
        training_data_table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_count_array 
    (
        training_data_table_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curStmt TEXT := '';
    result TEXT := 'ARRAY[';
    distValue INT := 0;
BEGIN
    
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT distinct_values FROM % ORDER BY id;',
            training_data_table_name
        ) 
        INTO curStmt; 
    
    FOR distValue IN EXECUTE (curStmt) LOOP
        result = result || distValue || ',';
    END LOOP;      
    
    result = rtrim(result, ',') || ']::INT4[]';
    
    return result;
    
END
$$ LANGUAGE plpgsql;


/**
 * @brief Insert a record to the meta data table
 * @param metaTableName name of meta table
 * @param columnName name of the column
 * @param columnType the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param isCont ture if the column is continuous 
 * @param tableName the key-value table name for the specified column
 * @param numOfDistValue the number of distinct values for the specified column
 *
 * @note  numOfDistValue includes the null value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_meta_table
    (
        metaTableName TEXT,
        columnName TEXT,
        columnType CHAR,   
        isCont BOOLEAN,     
        tableName TEXT,
        numOfDistValue INT    
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_meta_table 
    (
        metaTableName TEXT,
        columnName TEXT,
        columnType CHAR,   
        isCont BOOLEAN,     
        tableName TEXT,
        numOfDistValue INT         
    )
RETURNS void AS $$
DECLARE
    curStmt TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.assert(
        columnType = 'f' OR columnType = 'i' OR columnType = 'c',
        'column type must be ''f'', ''i'' or ''c''');
    
    SELECT MADLIB_SCHEMA.__format('INSERT INTO MADLIB_SCHEMA.% values(default, ''%'', ''%'', ''%'', ''%'', %);',
        ARRAY[metaTableName, columnName, columnType, MADLIB_SCHEMA.__to_char(isCont), tableName, MADLIB_SCHEMA.__to_char(numOfDistValue)]) 
        INTO curStmt; 
                
    EXECUTE curStmt;
    
END
$$ LANGUAGE plpgsql;


/**
 * @brief Get the feature index by the specified feature name
 * @param featureName the feature name
 * @param metaTableName the meta table name
 *
 * @return the feature id 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_index
    (
    featureName TEXT,
    metaTableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    featureName TEXT,
    metaTableName TEXT
    )
RETURNS INT AS $$
DECLARE
    curStmt TEXT;
    result INT := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT id FROM MADLIB_SCHEMA.% where columnName=''%'' AND columnType = ''f'' LIMIT 1;',
            metaTableName,
            featureName
        )
        INTO curStmt;
        
    EXECUTE curStmt INTO result;
    
    return result;
END
$$ LANGUAGE plpgsql;


/**
 * @brief   Get the feature name by the specified feature index
 * @param featureIndex the id of a feature
 * @param metaTableName the meta table name
 *
 * @return the feature name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name
    (
    featureIndex INT,
    metaTableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    featureIndex INT,
    metaTableName TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curStmt TEXT;
    toCharBase TEXT := '999999999';  
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT columnName FROM MADLIB_SCHEMA.% where id=% AND columnType = ''f'';',
            metaTableName,
            MADLIB_SCHEMA.__to_char(featureIndex)
        )
        INTO curStmt;
        
    EXECUTE curStmt INTO result;
    
    return result;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Get the column value by the specified column index and key
 * @param columnIndex the column id
 * @param key 
 * @param columnType the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param metaTableName the meta table name
 * 
 * @return the actual value for the specified key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_column_value
    (
    columnIndex INT,
    key INT,
    columnType CHAR,
    metaTableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    columnIndex INT,
    key INT,
    columnType CHAR,
    metaTableName TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curStmt TEXT;
    names TEXT[];
    result TEXT := '';
BEGIN

    IF (columnType = 'c') THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[columnName, tableName] FROM MADLIB_SCHEMA.% where columnType = ''c'';',
            metaTableName
            )
       INTO curStmt; 
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[columnName, tableName] FROM MADLIB_SCHEMA.% where id=% AND columnType = ''%'';',
            metaTableName,
            MADLIB_SCHEMA.__to_char(columnIndex),
            columnType
            )
           INTO curStmt;    
    END IF;
                   
    EXECUTE curStmt INTO names;
    
    PERFORM MADLIB_SCHEMA.ASSERT(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.ASSERT(names[2] IS NOT NULL, 'No such table name');
    
    IF (key IS NULL ) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% where key is null;',
            names[1],
            names[2]
        )
        INTO curStmt;        
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% where key=%;',
            names[1],
            names[2],
            MADLIB_SCHEMA.__to_char(key)
        )
        INTO curStmt;
    END IF;

    EXECUTE curStmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    return result;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Get the feature value by the specified feature index and key
 * @param featureIndex the feature id
 * @param key
 * @param metaTableName the meta table name  
 *
 * @return the value of specified key of the feature whose id specified in featureIndex
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_value
    (
    featureIndex INT,
    key INT,
    metaTableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    featureIndex INT,
    key INT,
    metaTableName TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(featureIndex, key, 'f', metaTableName)
        INTO result;
            
    return result;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Get the class value by the specified key
 * @param key
 * @param metaTableName the meta table name 
 *
 * @return the class value of the key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_value
    (
    key INT,
    metaTableName TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    key INT,
    metaTableName TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(0, key, 'c', metaTableName)
        INTO result;
            
    return result;
END
$$ LANGUAGE plpgsql;    


/**
 * @brief Test if the given columnName is a continuous column or not
 * @param columnName name of column
 * @contColumnNames an array contains all the continuous column names
 * 
 * @return true if the specified column is continuous, otherwise return false 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__is_continuous
    (
    columnName TEXT,
    contColumnNames TEXT[]
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    columnName TEXT,
    contColumnNames TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curStmt TEXT := '';
BEGIN
    IF (contColumnNames IS NOT NULL) THEN  
        FOR i IN 1..array_upper(contColumnNames, 1) LOOP
            IF (lower(contColumnNames[i]) = lower(columnName)) THEN
                return 't';
            END IF;
        END LOOP; 
    END IF;
    
    return 'f';
END
$$ LANGUAGE plpgsql;


/**
 * @brief Convert a tabular input to a sparse vector table
 *        all the columns of the input table will be used as feature
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param classColumnName class column's name
 * @param contColumnNames an array contains all the continuous feature
 *                        null means no continuous feature
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param verbosity ture if print the debug info  
 *
 * @note  feature names are not specified, use all the table's columns as feature
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    classColumnName TEXT, 
    contColumnNames TEXT[], 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    classColumnName TEXT, 
    contColumnNames TEXT[], 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    result TEXT := '';
begin
    
    SELECT MADLIB_SCHEMA.__convert_tbl_to_svec
        (
        inputTableName, 
        idColumnName, 
        null,
        classColumnName, 
        contColumnNames, 
        svecTableName,
        metaTableName,
        unknown_routine_id,
        verbosity
        ) 
        INTO result;
        
    return result;    
END
$$ LANGUAGE plpgsql;    


/**
 * @brief Convert a tabular input to a sparse vector table, no continuous features
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param classColumnName class column's name
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param verbosity ture if print the debug info 
 
 * @note  Feature names are not specified, use all the table's columns as feature
 *        No continuous features
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    classColumnName TEXT, 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    ); 
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    classColumnName TEXT, 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    result TEXT := '';
begin
    
    SELECT MADLIB_SCHEMA.__convert_tbl_to_svec
        (
        inputTableName, 
        idColumnName, 
        null,
        classColumnName, 
        null, 
        svecTableName,
        metaTableName,
        unknown_routine_id,
        verbosity
        ) 
        INTO result;
        
    return result;    
END
$$ LANGUAGE plpgsql;    


/**
 * @brief Convert a tabular input to a sparse vector table
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param featureNames an array contains all the featues
 *                     if it's null, we will get all the columns of the input table
 * @param classColumnName class column's name
 * @param contColumnNames an array contains all the continuous feature
 *                        null means no continuous feature
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param verbosity ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    featureNames TEXT[],
    classColumnName TEXT, 
    contColumnNames TEXT[], 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    featureNames TEXT[],
    classColumnName TEXT, 
    contColumnNames TEXT[], 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    columnName TEXT :='';
    curStmt TEXT := '';
    resultRec RECORD;
    index INT := 1;
    contColumnName TEXT;
    contColstmt TEXT := '';
    contColstmtQuote TEXT := '';
    classColumnLowerName TEXT := '';
    idColumnlowerName TEXT := '';
    colTableName TEXT := '';
    dropColStmt TEXT := '';
    svecColstmt TEXT := '';
    execBegin TIMESTAMP;
BEGIN
    
    execBegin = clock_timestamp();

    classColumnLowerName = btrim(lower(classColumnName), ' ');
    idColumnlowerName = btrim(lower(idColumnName), ' ');
    
    PERFORM MADLIB_SCHEMA.__create_meta_table(metaTableName);
    
    IF (contColumnNames IS NOT NULL) THEN  
        FOR i IN 1..array_upper(contColumnNames, 1) LOOP
            contColumnName = lower(contColumnNames[i]);
            contColstmtQuote = contColstmtQuote || quote_literal(contColumnName) || ',';
            contColstmt = contColstmt || ',' || contColumnName;
            
            SELECT MADLIB_SCHEMA.__process_cont_column
                (
                    inputTableName, 
                    idColumnlowerName, 
                    contColumnName,
                    svecTableName,
                    metaTableName,
                    't',
                    verbosity
                ) INTO curStmt;
        
            dropColStmt = dropColStmt || curStmt; 
            
        END LOOP; 
    END IF;
    
    PERFORM MADLIB_SCHEMA.__create_svec_table
        (
            inputTableName, 
            idColumnlowerName, 
            contColstmt,
            svecTableName,
            verbosity
        );

    contColstmtQuote = contColstmtQuote || '''' || idColumnlowerName || '''';
     
    IF (featureNames IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format(
            'select trim(both '' '' from attname) as attname from pg_attribute 
                where attrelid = ''%''::regclass and attnum > 0 and (attname NOT IN (%)) and NOT attisdropped;', 
            inputTableName, contColstmtQuote)
            INTO curStmt;   
        
        FOR columnName IN EXECUTE curStmt LOOP
            
            IF (columnName <> classColumnLowerName) THEN
                colTableName = metaTableName || '_' || columnName;
                
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        inputTableName, 
                        idColumnlowerName, 
                        columnName,
                        'f',
                        colTableName ,
                        svecTableName,
                        metaTableName,
                        unknown_routine_id,
                        't',
                        verbosity
                    )
                    INTO curStmt;
                    
                dropColStmt = dropColStmt || curStmt;
                
                svecColstmt = svecColstmt || ',' || columnName;
            
            END IF;
        END LOOP;
    ELSE
        FOR i IN 1..array_upper(featureNames, 1) LOOP
            columnName = featureNames[i];
            IF (NOT MADLIB_SCHEMA.__is_continuous(columnName, contColumnNames)) THEN
                colTableName = metaTableName || '_' || columnName;    
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        inputTableName, 
                        idColumnlowerName, 
                        columnName,
                        'f',
                        colTableName ,
                        svecTableName,
                        metaTableName,
                        unknown_routine_id,
                        't',
                        verbosity
                    )
                    INTO curStmt;
                    
                dropColStmt = dropColStmt || curStmt;
                
                svecColstmt = svecColstmt || ',' || columnName;
            END IF;    
        END LOOP;
        
        
    END IF;
    
    -- class column
    colTableName = metaTableName || '_' || classColumnLowerName;
    PERFORM MADLIB_SCHEMA.__process_class_column
        (
            inputTableName, 
            idColumnlowerName, 
            classColumnLowerName,
            colTableName,
            svecTableName,
            metaTableName,
            't',
            verbosity
        ) ;

    svecColstmt = contColstmt || svecColstmt;
    svecColstmt = ltrim(svecColstmt, ',') ;
    
    SELECT MADLIB_SCHEMA.__convert_tbl_to_svec_post
        (
            idColumnlowerName,
            svecTableName,
            dropColStmt, 
            svecColstmt, 
            metaTableName,
            't',
            verbosity
        ) 
        INTO curStmt;
    
    IF (verbosity) THEN
        RAISE INFO 'Conversion time:%', clock_timestamp() - execBegin;
    END IF;
        
    return svecTableName;
END
$$ LANGUAGE plpgsql;    


/**
 * @brief Convert a tabular input to a sparse vector table for classification/score function
 * @param inputTableName the input table name
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param verbosity ture if print the debug info 
 *
 * @note    feature (discrete or continuous) names and keys were retrieved from meta table
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_tbl_to_svec
    (
    inputTableName TEXT, 
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curStmt TEXT;
    idColumnName TEXT;
    temp TEXT := '';
    resultRec RECORD;
    contColstmt TEXT := '';
    dropColStmt TEXT := '';
    tempDropColStmt TEXT := '';
    svecColstmt TEXT := '';
    execBegin TIMESTAMP;
BEGIN
    
    execBegin = clock_timestamp();
        
    SELECT MADLIB_SCHEMA.__format('SELECT columnName FROM MADLIB_SCHEMA.% WHERE columnType=''i'';',
        metaTableName)
        INTO curStmt; 
    
    EXECUTE curStmt INTO idColumnName;
    
    SELECT MADLIB_SCHEMA.__format('SELECT columnName FROM MADLIB_SCHEMA.% WHERE isCont ORDER BY id;',
        metaTableName)
        INTO curStmt; 
        
    FOR temp IN EXECUTE curStmt LOOP
        contColstmt = contColstmt || ',' || temp;
        
        SELECT MADLIB_SCHEMA.__process_cont_column
            (
                inputTableName, 
                idColumnName, 
                temp,
                svecTableName,
                metaTableName,
                'f',
                verbosity
            ) INTO tempDropColStmt;
    
        dropColStmt = dropColStmt || tempDropColStmt; 
        
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__create_svec_table
        (
            inputTableName, 
            idColumnName, 
            contColstmt,
            svecTableName,
            verbosity
        );
    
    SELECT MADLIB_SCHEMA.__format('SELECT columnName, columnType, isCont, tableName 
                        FROM MADLIB_SCHEMA.% 
                        WHERE (columnType <> ''i'') AND (NOT isCont) ORDER BY id',
        metaTableName)
        INTO curStmt; 
                
    FOR resultRec IN EXECUTE curStmt LOOP
        IF (resultRec.columnType = 'f' AND (NOT resultRec.isCont)) THEN
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        inputTableName, 
                        idColumnName, 
                        resultRec.columnName,
                        'f',
                        resultRec.tableName,
                        svecTableName,
                        metaTableName,
                        unknown_routine_id,
                        'f',
                        verbosity
                    )
                    INTO curStmt;
                dropColStmt = dropColStmt || curStmt;
                
                svecColstmt = svecColstmt || ',' || resultRec.columnName;
                
        ELSIF (resultRec.columnType = 'c') THEN
                PERFORM MADLIB_SCHEMA.__process_class_column
                    (
                        inputTableName, 
                        idColumnName, 
                        resultRec.columnName,
                        resultRec.tableName,
                        svecTableName,
                        metaTableName,
                        'f',
                        verbosity
                    ) ;
        ELSE
            -- nothing need to do for id column
        END IF;
    END LOOP;
    
    svecColstmt = contColstmt || svecColstmt;
    svecColstmt = ltrim(svecColstmt, ',') ;
    
    SELECT MADLIB_SCHEMA.__convert_tbl_to_svec_post
        (
            idColumnName,
            svecTableName,
            dropColStmt, 
            svecColstmt, 
            metaTableName,
            'f',
            verbosity
        ) 
        INTO curStmt;
    
    IF (verbosity) THEN
        RAISE INFO 'Conversion time:%', clock_timestamp() - execBegin;
    END IF;
        
    return svecTableName;
END
$$ LANGUAGE plpgsql;
   
   
/**
 * @brief The post process for converting
 * @param idColumnName the name of id column 
 * @param svecTableName the sparse vector table name
 * @param dropColStmt the drop column statements
 *                    we will copy all the column name to the sparse vector table
 *                    but it these columns' value is the key, after construct the 
 *                    sparse vector, we will drop these auxiliary table
 * @param metaTableName the meta table name
 * @param is__create_meta_table true if create the meta table
 *                              for classify/score functionality, which will convert
 *                              the input table, in this case, we needn't create the
 *                              meta table. Just make use of the table                               
 * @return the string contains the drop column statement   
 * @param isPersistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 */   
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_tbl_to_svec_post
    (
    idColumnName TEXT,
    svecTableName TEXT,
    dropColStmt TEXT, 
    svecColstmt TEXT, 
    metaTableName TEXT,
    is__create_meta_table BOOLEAN,
    verbosity BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_tbl_to_svec_post
    (
    idColumnName TEXT,
    svecTableName TEXT,
    dropColStmt TEXT, 
    svecColstmt TEXT, 
    metaTableName TEXT,
    is__create_meta_table BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS void AS $$
declare
    curStmt TEXT := '';
begin
    
    IF (is__create_meta_table) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_meta_table(metaTableName, idColumnName, 'i', 'f', '', 0);
    END IF;
    
    -- Add the feature column
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % ADD COLUMN feature MADLIB_SCHEMA.svec', svecTableName) 
        INTO curStmt;
    EXECUTE curStmt;
            
    -- set the feature column 
    SELECT MADLIB_SCHEMA.__format('UPDATE % set feature=array[%]::float[]::MADLIB_SCHEMA.svec', svecTableName, svecColstmt)
        INTO curStmt;
    
    --RAISE INFO 'update stmt2: %', curStmt;
    EXECUTE curStmt;

    EXECUTE dropColStmt;
    
END
$$ LANGUAGE plpgsql;


/**
 * @brief Create the sparse vector table
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param contColstmt a string contains all the continuous feature names 
 *                    with delimiter ','
 * @param svecTableName the sparse vector table name
 * @param verbosity ture if print the debug info 
 *
 * @return the sparse vector table name  
 * @note    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_svec_table
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    contColstmt TEXT,
    svecTableName TEXT,
    verbosity BOOLEAN
    );
    
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_svec_table
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    contColstmt TEXT,
    svecTableName TEXT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    curStmt TEXT := '';
    rec RECORD;
begin
    --RAISE INFO 'continuous columns:%', contColstmt;
    -- create result table, and get all the id and continuous columns' value
    EXECUTE 'DROP TABLE IF EXISTS ' || svecTableName || ' CASCADE;';
    
    --RAISE INFO '__create_svec_table: %', contColstmt;
    -- svecColstmt has a comma in the front
    SELECT MADLIB_SCHEMA.__format(
        'CREATE TABLE %(id %) AS SELECT % % FROM % DISTRIBUTED BY(id);', 
        ARRAY[svecTableName, contColstmt, idColumnName, contColstmt, inputTableName])
        INTO curStmt;
            
    EXECUTE curStmt;
     
    return  svecTableName ;
END
$$ LANGUAGE plpgsql;


/**
 * @brief Process the continuous feature
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param columnName name of the column
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param isPersistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return the string contains the drop column statement     
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_cont_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    );
    
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_cont_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    curStmt TEXT := '';
    num INT := 0;
begin
    
    -- insert the continuous features
        -- insert the continuous features
    IF (isPersistent) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT COUNT(DISTINCT %) FROM %',
            columnName, inputTableName)
            INTO curStmt;
        
        EXECUTE curStmt INTO num;
        
        PERFORM MADLIB_SCHEMA.__insert_into_meta_table(metaTableName, columnName, 'f', 't', '', num);
    END IF;
    
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % DROP COLUMN % CASCADE;', svecTableName, columnName) 
        INTO curStmt;
    
    return curStmt;

END
$$ LANGUAGE plpgsql;


/**
 * @brief   Process the class column
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param columnName name of the column
 * @param colTableName the table name for the specified column
 *                     this table is the key-value table for this column
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param isPersistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return an empty string      
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_class_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    colTableName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    );
        
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_class_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    colTableName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    curStmt TEXT := '';
    columnType CHAR := 'c';
begin
    PERFORM MADLIB_SCHEMA.__process_discrete_column
    (
        inputTableName, 
        idColumnName, 
        columnName,
        columnType,
        colTableName,
        svecTableName,
        metaTableName,
        1,
        isPersistent,
        verbosity
    );
    -- rename the class column with "class"
    IF ((columnName IS NOT NULL) AND (columnName <> '') AND (columnName <> 'class')) THEN
        SELECT MADLIB_SCHEMA.__format('ALTER TABLE % RENAME % to class', svecTableName, columnName) 
            INTO curStmt;
        
        EXECUTE curStmt;
    END IF;
    
    return '';
END
$$ LANGUAGE plpgsql;


/**
 * @brief   Process the discrete feature
 * @param inputTableName the input table name
 * @param idColumnName the name of id column 
 * @param columnName name of the column
 * @param columnType the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param colTableName the table name for the specified column
 *                     this table is the key-value table for this column
 * @param svecTableName the sparse vector table name
 * @param metaTableName the meta table name
 * @param isPersistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return the string contains the drop column statement    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_discrete_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    columnType CHAR,
    colTableName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_discrete_column
    (
    inputTableName TEXT, 
    idColumnName TEXT, 
    columnName TEXT,
    columnType CHAR,
    colTableName TEXT,
    svecTableName TEXT,
    metaTableName TEXT,
    unknown_routine_id INT,
    isPersistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    curStmt TEXT := '';
    index INT := 1;
    name TEXT := '';
    temp TEXT;
begin
    -- For each column, we will create a table for it. 
    -- The table stores the key->value, and distributed by value for parallelism                            
    IF (isPersistent) THEN
        EXECUTE 'DROP TABLE IF EXISTS MADLIB_SCHEMA.' || colTableName || ';';
                
        -- create table with columns: key, value
        SELECT MADLIB_SCHEMA.__format(
            'CREATE TABLE MADLIB_SCHEMA.% (%, key)  
            AS SELECT DISTINCT %, 1 FROM %   
            DISTRIBUTED BY(%);', 
            ARRAY[
            colTableName, 
            columnName,
            columnName, 
            inputTableName,
            columnName
            ]) 
            INTO curStmt;
            
        --RAISE INFO 'Create table: %', curStmt;
        EXECUTE curStmt;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% ORDER BY %',
            columnName,
            colTableName,
            columnName)
            INTO curStmt;
            
       index = 1;
       FOR name IN EXECUTE (curStmt) LOOP
            IF ((name IS null) OR (name = '?') OR (length(btrim(name, ' ')) = 0)) THEN
                temp = 'null';
                IF (unknown_routine_id = 2) THEN
                    temp = MADLIB_SCHEMA.__to_char(index);
                    index = index + 1;
                END IF;
                
                IF (name IS NULL) THEN
                    SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.%  SET key=% WHERE % IS NULL',
                    colTableName, temp, columnName)
                    INTO curStmt;
                ELSE
                    SELECT MADLIB_SCHEMA.__format(
                        'UPDATE MADLIB_SCHEMA.% SET key = % WHERE %=''%'';',
                        colTableName,
			             temp,
                        columnName,
                        name)
                        INTO curStmt;
                END IF;
		
		      EXECUTE curStmt;
		      
            ELSE
                SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.% SET key=% WHERE %=''%'';',
                    colTableName,
                    MADLIB_SCHEMA.__to_char(index),
                    columnName,
                    replace(name, '''', ''''''))
                    INTO curStmt;
                index = index + 1;
            END IF;
            
            EXECUTE curStmt;
        END LOOP;
    END IF;
    

    
    -- Add the column to the result table
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % ADD COLUMN % INT', svecTableName, columnName)
            INTO curStmt;
    EXECUTE curStmt;
    
    -- update result table (value -> key)
    SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=s.key FROM MADLIB_SCHEMA.% s, % p 
                            WHERE (s.% = p.% OR (s.% is NULL AND p.% is NULL)) AND %.id=p.%;',
                      ARRAY[
                      svecTableName,
                      columnName,
                      colTableName,
                      inputTableName,
                      columnName,
                      columnName,
                      columnName,
                      columnName,
                      svecTableName,
                      idColumnName])
             INTO curStmt;
    --RAISE INFO 'update stmt: %', curStmt;
    EXECUTE curStmt;     
    
    IF (isPersistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_meta_table(metaTableName, columnName, columnType, 'f', colTableName, index - 1);
    END IF;
    
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % DROP COLUMN % CASCADE;', svecTableName, columnName) 
    INTO curStmt;
    
    return curStmt;
    
END
$$ LANGUAGE plpgsql;

/**
 * @brief Convert a string with delimiter ',' to an array 
 * @param csvString a string with delimiter ','
 *
 * @return the splitting string array    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__convert_csv_to_array
    (
    csvString TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__convert_csv_to_array 
    (
    csvString TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret TEXT[];
    str_val TEXT;
    index INTEGER;
BEGIN
    ret = string_to_array(lower(csvString), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = btrim(ret[index], ' ');
        END LOOP;
    END IF;

    return ret;
END
$$ LANGUAGE plpgsql;
          
