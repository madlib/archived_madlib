m4_include(`SQLCommon.m4')

/* Own macro definitions */
m4_ifelse(
    m4_eval(
        m4_ifdef(`__GREENPLUM__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ * 100 + __DBMS_VERSION_MINOR__ < 401
    ), 1,
    `m4_define(`__GREENPLUM_PRE_4_1__')'
)

/*
 * @brief cast any value to text
 * @param val   a value with any specific type
 *
 * @note Greenplum doesn't support boolean to text casting
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val anyelement
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val anyelement
    ) 
RETURNS TEXT AS $$
DECLARE
    is_bool    BOOLEAN;
BEGIN
    IF (val is NULL) THEN
        return null::text;
    END IF;
    SELECT pg_typeof(val) = 'boolean'::regtype INTO is_bool;
    IF (is_bool) THEN
         IF (val::boolean) THEN
            RETURN 'true';
         ELSE
            RETURN 'false';
         END IF;
    END IF;
    
    RETURN val::TEXT;

END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Format a string with the value in allvalues array
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 *       The number of '%' should be equal with the length of array allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    allvalues   TEXT[]
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    allvalues   TEXT[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt        TEXT := '';
    parts       TEXT[];
    idx         INT := 1;
    curpart     TEXT;
    curvalue    TEXT;
BEGIN
    SELECT regexp_split_to_array(format_str, '%') INTO parts;
    
    LOOP
        curpart = parts[idx];
        curValue = allvalues[idx];
        IF (curpart IS NULL OR curValue IS NULL ) THEN
            EXIT;
        END IF;
        
        stmt = stmt || curpart || curValue;
        idx = idx + 1;
    END LOOP;
    
    IF (curpart IS NOT NULL) THEN
        stmt = stmt || curpart;
    END IF;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Short form to format a string with four parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 * @param value4 The fouth value
    
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT,
    value4      TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT,
    value4      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3, value4]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with three parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with two parameters
 * @param value1 The first value
 * @param value2 The second value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with a parameter
 * @param value1 The first value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief   Format a string with the value in allvalues array
 *          All the char ('%') in format_str will be replaced with allvalues
 *          If a element in quotes is t, then the value in allvalues will be quoted.
 *          Such as, allvalues: ['1', '2'], and quotes: ['f', 't']
 *          then allvalues will be change to [''1'', ''2''] 
 *
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 * @param quotes specify which string in the array should add quote
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str      TEXT, 
    allvalues       TEXT[], 
    quotes          BOOLEAN[]
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str      TEXT, 
    allvalues       TEXT[], 
    quotes          BOOLEAN[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt            TEXT := '';
    temp_allvalues  TEXT[];
    idx             INT := 1;
    quote           TEXT;
BEGIN
    LOOP
        quote = quotes[idx];
        IF (quote IS NULL) THEN
            EXIT;
        END IF;
        stmt = allvalues[idx];
        IF (quote) THEN
            SELECT quote_literal( allvalues[idx] ) INTO stmt;
        END IF;
        
        temp_allvalues[idx] = stmt;
        idx = idx + 1;
    END LOOP;
    
    SELECT MADLIB_SCHEMA.__format(format_str, temp_allvalues) INTO stmt;
    
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief assert function
 * @param condition the assert condition
 * @param reason the reason string, which will be display when assert failure
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Test if the specified table exists or not
 *
 * @param full_table_name    The full table name
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    full_table_name    TEXT
    ) 
RETURNS BOOLEAN AS 
'MODULE_PATHNAME', 'table_exists' 
LANGUAGE C IMMUTABLE;

/*
 * @brief Test if the specified column exists or not
 *
 * @param full_table_name    The full table name
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__column_exists
    (
    full_table_name   TEXT,
    column_name       TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curstmt         TEXT := '';
    result          INT  := 0;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            (full_table_name IS NOT NULL) AND (column_name IS NOT NULL), 
            'the table name and column name must not be null'
        );
                
    IF (MADLIB_SCHEMA.__table_exists(full_table_name)) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT COUNT(*) 
                 FROM pg_catalog.pg_attribute 
                 WHERE attnum > 0 AND 
                       (NOT attisdropped) AND
                       attname = ''%'' AND
                       attrelid = ''%''::regclass',
                ARRAY[
                    column_name,
                    full_table_name
                ]
            ) INTO curstmt;
            
        EXECUTE curstmt INTO result;
        
        RETURN result >= 1;         
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief assert if the specified table under the specified schema exists or not
 * @param schema_name schema name of the table
 * @param table_name the short table name without schema name
 * @param existence ture if assert table exists, otherwise false
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    schema_name     TEXT,
    table_name      TEXT,
    existence       BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    schema_name     TEXT,
    table_name      TEXT,
    existence       BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    err_msg     TEXT;
BEGIN
    IF (existence) THEN
        err_msg = 'assertion failure. Table: ''' || table_name || ''' does not exist';
    ELSE
        err_msg = 'assertion failure. Table: ''' || table_name || ''' already exists';
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert
        (
        MADLIB_SCHEMA.__table_exists(schema_name||'.'||table_name) = existence, 
        err_msg
        );
END
$$ LANGUAGE PLPGSQL;

/*
 * This is a global table to store information for various tree training.
 */
DROP TABLE IF EXISTS MADLIB_SCHEMA.training_info;
CREATE TABLE MADLIB_SCHEMA.training_info
    (
    tree_table_name TEXT        NOT NULL,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT,
    PRIMARY KEY (tree_table_name)
    ) m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (tree_table_name)');
GRANT ALL PRIVILEGES ON MADLIB_SCHEMA.training_info TO PUBLIC;

/*
 * @brief get the meta table name by the tree table name
 * @param tree_table tree table name
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    metatable_name TEXT := '';
BEGIN

    PERFORM MADLIB_SCHEMA.__assert
            (
                MADLIB_SCHEMA.__get_schema_name(tree_table),
                MADLIB_SCHEMA.__strip_schema_name(tree_table),
                't'
            );     
    
    PERFORM MADLIB_SCHEMA.__assert
            (
                'MADLIB_SCHEMA',
                'training_info',
                't'
            ); 
            
    SELECT training_metatable_name 
    FROM MADLIB_SCHEMA.training_info 
    WHERE tree_table_name = tree_table 
    INTO metatable_name;
    
    RETURN metatable_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the class table name by the metatable name
 * @param metatable_name name of metatable
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_classtable_name
    (
    metatable_name TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_classtable_name
    (
    metatable_name TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    classtable_name TEXT;
BEGIN

    PERFORM MADLIB_SCHEMA.__assert
            (
                'MADLIB_SCHEMA',
                metatable_name,
                't'
            ); 
            
    EXECUTE ' SELECT table_name 
              FROM MADLIB_SCHEMA.' || metatable_name ||
            ' WHERE column_type = ''c'';'  
    INTO classtable_name;
    
    RETURN classtable_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the encoding table name by tree table name
 * @param tree_table tree table name
 * 
 * @return the encoding table name
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    encoded_table_name TEXT := '';
BEGIN
    SELECT training_encoded_table_name 
    FROM MADLIB_SCHEMA.training_info
    WHERE tree_table_name = tree_table 
    INTO encoded_table_name;
    
    RETURN encoded_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the unknown values processing routine id 
 * @param tree_table tree table name         
 *  
 * @note currently, we support 'explicit' and 'ignore'
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
DECLARE
    name TEXT;
BEGIN
    
    PERFORM MADLIB_SCHEMA.__assert
    (
        'MADLIB_SCHEMA',
        'training_info',
        't'
    );
        
    SELECT how2handle_missing_value 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  tree_table_name = tree_table 
    INTO   name;
        
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSIF (name = 'explicit') THEN
        RETURN 2;
    ELSE
        RAISE EXCEPTION '__get_routine_id: %', name; 
    END IF;
    
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the feature column's name
 * @param tree_table tree table name         
 *  
 * @return the name of feature column
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    feature_name TEXT;
BEGIN
    SELECT feature_col_names 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  tree_table_name = tree_table 
    INTO   feature_name;
        
    RETURN feature_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief Remove the trained tree from training info table 
 * @param tree_table tree table name 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    ) 
RETURNS void AS $$
BEGIN
    DELETE FROM MADLIB_SCHEMA.training_info WHERE tree_table_name = tree_table;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief insert the trained tree into training info table 
 * @param result_tree_table_name        tree table name
 * @param training_table_name           training table name
 * @param training_metatable_name       name of training data table
 * @param training_encoded_table_name   name of encoding table 
 * @param validation_table_name         validation table name
 * @param how2handle_missing_value      the routine to process unknown values
 * @param split_criterion               the name of split criterion
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name      TEXT,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT  
    );
               
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name      TEXT,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT  
    )
RETURNS void AS $$
BEGIN
    INSERT INTO MADLIB_SCHEMA.training_info VALUES
                        (
                        result_tree_table_name,
                        training_table_name,
                        training_metatable_name,
                        training_encoded_table_name,
                        validation_table_name,
                        how2handle_missing_value,
                        split_criterion
                        );
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief  set the encoding table name and training data table name 
 *         in the training info table
 * @param result_tree_table_name tree table name
 * @param metatable_name name of training data table
 * @param encoded_table_name name of encoded table 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name  TEXT,
    metatable_name          TEXT,
    encoded_table_name      TEXT
    );        
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name  TEXT,
    metatable_name          TEXT,
    encoded_table_name      TEXT
    ) 
RETURNS void AS $$
BEGIN
    UPDATE MADLIB_SCHEMA.training_info 
    SET training_metatable_name = metatable_name,
        training_encoded_table_name = encoded_table_name 
    WHERE tree_table_name = result_tree_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief  Strip the schema name from the full name 
 * @param full_name the full name of table (with schema name)
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
BEGIN
    str_val = trim(both ' ' FROM split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        str_val = trim(both ' ' FROM full_name);
    END IF;
    RETURN str_val;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the schema name from a full database object name
 * @param full_name the fullname of a database object
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
    ret_val TEXT;
BEGIN
    str_val = btrim(split_part(full_name, '.', 2), ' ');

    IF( str_val is null or str_val = '' ) THEN
        ret_val = 'public';
    ELSE
        ret_val = btrim(split_part(full_name, '.', 1), ' ');
    END IF;
    RETURN ret_val;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Drop the metatable and all the KV tables
 * @param table_name the metatable name
 *
 * @note MADLIB_SCHEMA will be added to the table_name automatically
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__drop_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    name    TEXT;
BEGIN
    IF ( table_name is NULL ) THEN
        RETURN;
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 't');
    
    SELECT MADLIB_SCHEMA.__format
            (
            'SELECT table_name FROM MADLIB_SCHEMA.% 
            WHERE table_name IS NOT NULL AND length(trim(table_name, '' '')) > 1',
            table_name
            ) 
    INTO curstmt;
        
    FOR name IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', name, 't');
        EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || table_name || ' CASCADE;';
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create the metatable 
 * @param table_name the metatable name  
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(table_name)) <= 63, 
            'The maximum length of ' || table_name || ' is 63'
        );
        
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 'f');
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    EXECUTE 'CREATE TABLE MADLIB_SCHEMA.'|| table_name || E'(
        id SERIAL,
        column_name TEXT,
        column_type CHAR,    
        is_cont BOOLEAN,     
        table_name TEXT,
        num_dist_value INT
    ) m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)');';
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert a record to the meta data table
 * @param metatable_name name of meta table
 * @param column_name name of the column
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param is_cont ture if the column is continuous 
 * @param table_name the key-value table name for the specified column
 * @param num_dist_value the number of distinct values for the specified column
 *
 * @note  num_dist_value includes the null value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_metatable
    (
    metatable_name      TEXT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT    
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    metatable_name      TEXT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT         
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert(
        column_type = 'f' OR column_type = 'i' OR column_type = 'c',
        'column type must be ''f'', ''i'' or ''c''');
    
    SELECT MADLIB_SCHEMA.__format(
        'INSERT INTO MADLIB_SCHEMA.% VALUES(default, ''%'', ''%'', ''%'', ''%'', %);',
        ARRAY[
        metatable_name, 
        column_name, 
        column_type, 
        MADLIB_SCHEMA.__to_char(is_cont), 
        table_name, 
        MADLIB_SCHEMA.__to_char(num_dist_value)
        ]) 
        INTO curstmt; 
                
    EXECUTE curstmt;
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct vlaues for the given feature
 * @param metatable_name    name of meta table
 * @param feature_id        the index of feature in the metatable
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__distinct_feature_value
    (
    metatable_name  TEXT,
    feature_id      INT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    metatable_name  TEXT,
    feature_id      INT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt     TEXT := '';
    result      INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT num_dist_value 
        FROM MADLIB_SCHEMA.% WHERE column_type=''f'' AND id = %;',
        metatable_name,
        MADLIB_SCHEMA.__to_char(feature_id)
        )
    INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the number of features
 * @param metatable_name    name of metatable
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_feature
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(*) 
        FROM MADLIB_SCHEMA.% WHERE column_type=''f'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct class values
 * @param metatable_name    name of metatable
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt             TEXT := '';
    result              INT4 := 0;
    class_table_name    TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT table_name 
        FROM MADLIB_SCHEMA.% WHERE column_type=''c'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO class_table_name;
    
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(key)
        FROM MADLIB_SCHEMA.%',
        class_table_name
        ) INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the feature index by the specified feature name
 * @param feature_name the feature name
 * @param metatable_name the meta table name
 *
 * @return the feature id 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_index
    (
    feature_name    TEXT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    feature_name    TEXT,
    metatable_name  TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT  id 
             FROM    MADLIB_SCHEMA.% 
             WHERE   column_name=''%'' AND column_type = ''f'' 
             LIMIT   1;',
            metatable_name,
            feature_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature name by the specified feature index
 * @param feature_index the id of a feature
 * @param metatable_name the meta table name
 *
 * @return the feature name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name
    (
    feature_index   INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index   INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name 
             FROM   MADLIB_SCHEMA.% 
             WHERE  id = % AND column_type = ''f'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(feature_index)
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;



/*
 * @brief Get the feature name list
 * @param metatable_name the meta table name
 *
 * @return the feature name list 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name_list
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_list    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := 'ARRAY[';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   MADLIB_SCHEMA.' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',') || ']';
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Concat all the feature names with delimeter ','
 * @param metatable_name the meta table name
 *
 * @return the text representing feature names with delimeter ','
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name_in_selectstmt
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_in_selectstmt    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := '';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   MADLIB_SCHEMA.' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',');
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the column value by the specified column index and key
 * @param column_index the column id
 * @param key the key of returned value
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param metatable_name the meta table name
 * 
 * @return the actual value for the specified key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_column_value
    (
    column_index    INT,
    key             INT,
    column_type     CHAR,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index    INT,
    key             INT,
    column_type     CHAR,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curstmt     TEXT;
    names       TEXT[];
    result      TEXT := '';
BEGIN
    IF (column_type = 'c') THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] 
             FROM   MADLIB_SCHEMA.% 
             WHERE  column_type = ''c'';',
            metatable_name
            )
       INTO curstmt; 
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] 
             FROM   MADLIB_SCHEMA.% 
             WHERE  id = % AND column_type = ''%'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(column_index),
            column_type
            )
           INTO curstmt;    
    END IF;
                   
    EXECUTE curstmt INTO names;
    
    PERFORM MADLIB_SCHEMA.__assert(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.__assert(names[2] IS NOT NULL, 'No such table name');
    
    IF (key IS NULL ) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% WHERE key IS NULL;',
            names[1],
            names[2]
        )
        INTO curstmt;        
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT MADLIB_SCHEMA.__to_char(%) FROM MADLIB_SCHEMA.% WHERE key = %;',
            names[1],
            names[2],
            MADLIB_SCHEMA.__to_char(key)
        )
        INTO curstmt;
    END IF;

    EXECUTE curstmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature value by the specified feature index and key
 * @param feature_index the feature id
 * @param key the key of returned value
 * @param metatable_name the meta table name  
 *
 * @return the value of specified key of the feature whose id specified in feature_index
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_value
    (
    feature_index   INT,
    key             INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index   INT,
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(feature_index, key, 'f', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the id column name
 * @param metatable_name the meta table name
 *
 * @return the id column name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_id_column_name
    (
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_id_column_name    
    (
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            'MADLIB_SCHEMA',
            metatable_name,
            't'
        );
        
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name 
             FROM   MADLIB_SCHEMA.% 
             WHERE  column_type = ''i'' LIMIT 1',
            metatable_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the class column name
 * @param metatable_name the meta table name
 *
 * @return the class column name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_column_name
    (
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name    
    (
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            'MADLIB_SCHEMA',
            metatable_name,
            't'
        );
        
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name 
             FROM   MADLIB_SCHEMA.% 
             WHERE  column_type = ''c'' LIMIT 1',
            metatable_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the class value by the specified key
 * @param key key the key of returned value
 * @param metatable_name the meta table name 
 *
 * @return the class value of the key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_value
    (
    key             INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(0, key, 'c', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;    

/*
 * @brief check if the input table has unsupported data type or not
 * @param full_table_name <schema name>.<table name> 
 * @param feature_columns one array including all feature names
 * @param id_column the name of the id column        
 * @param class_column the name of the class column        
 *
 * @return if the table has unsupported data types, then raise exception
 *         otherwise return nothing
 *
 * NOTE: All the supported type are hardcoded in the function body     
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__validate_input_table
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    )
RETURNS void AS $$  
DECLARE
    rec             RECORD;
    stmt            TEXT;
    all_columns     TEXT='';
    index           INT;
BEGIN
    -- find the first (LIMIT 1) unsupported data type if the input table has.
    stmt= 'SELECT atttypid 
    FROM pg_attribute 
    WHERE attrelid ='||quote_literal(full_table_name)||'::regclass  AND
          attnum > 0                                                AND 
          (not attisdropped)                                        AND
          atttypid NOT IN 
          (
              SELECT unnest
                    (
                        ARRAY[
                            ''SMALLINT''::regtype::oid,
                            ''INT''::regtype::oid, 
                            ''BIGINT''::regtype::oid, 
                            ''FLOAT8''::regtype::oid, 
                            ''REAL''::regtype::oid, 
                            ''NUMERIC''::regtype::oid,
                            ''DECIMAL''::regtype::oid,
                            ''INET''::regtype::oid, 
                            ''CIDR''::regtype::oid, 
                            ''MACADDR''::regtype::oid, 
                            ''BOOLEAN''::regtype::oid, 
                            ''CHAR''::regtype::oid, 
                            ''VARCHAR''::regtype::oid, 
                            ''TEXT''::regtype::oid, 
                            ''"char"''::regtype::oid, 
                            ''DATE''::regtype::oid, 
                            ''TIME''::regtype::oid,
                            ''TIMETZ''::regtype::oid, 
                            ''TIMESTAMP''::regtype::oid, 
                            ''TIMESTAMPTZ''::regtype::oid, 
                            ''INTERVAL''::regtype::oid
                        ]
                    )
          ) ';

    IF (feature_columns IS NOT NULL) THEN
        -- If user do not specify feature columns, we use all those columns.
        -- Otherwise, we just need to check those specified columns.
        index = array_lower(feature_columns, 1);
        WHILE (index <= array_upper(feature_columns, 1)) LOOP
            all_columns = all_columns || quote_literal(feature_columns[index]) || ',';
            index = index+1;
        END LOOP; 
        
        all_columns = all_columns || quote_literal(id_column) || ',';
        all_columns = all_columns || quote_literal(class_column);
        stmt = stmt ||' AND attname IN ('||all_columns||') ';
    END IF;
    
    stmt = stmt||' LIMIT 1;';
    
    EXECUTE stmt INTO rec;
            
    IF (rec IS NOT NULL) THEN
        -- Print the first unsupported data type, and supported types.
        RAISE EXCEPTION 'Unsupported data type [%]. Supported types include:
                         SMALLINT, INT, BIGINT, FLOAT8, REAL, NUMERIC,
                         DECIMAL, INET, CIDR, MACADDR, BOOLEAN,
                         CHAR, VARCHAR, TEXT, "char", 
                         DATE, TIME, TIMETZ, TIMESTAMP, TIMESTAMPTZ, and INTERVAL', 
                         rec.atttypid::regtype;
    END IF;
        
    RETURN;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief check if the input table has unsupported data type or not
 * @param full_table_name <schema name>.<table name> 
 *
 * @return if the table has unsupported data types, then raise exception
 *         otherwise return nothing
 *
 * NOTE: All the supported type are hardcoded in the function body     
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__validate_input_table
    (
    full_table_name     TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT
    )
RETURNS void AS $$  
BEGIN
    PERFORM MADLIB_SCHEMA.__validate_input_table
                        (
                            full_table_name,
                            NULL,
                            NULL,
                            NULL
                        );     
    RETURN;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Test if the given column_name is a continuous column or not
 * @param column_name name of column
 * @cont_column_names an array contains all the continuous column names
 * 
 * @return true if the specified column is continuous, otherwise return false 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__is_continuous
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            IF (cont_column_names[i] = column_name) THEN
                RETURN 't';
            END IF;
        END LOOP; 
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief encode a tabular table
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param feature_names         an array contains all the feature. If it's null, 
                                we will get all the columns of the input table
 * @param class_column_name     class column's name
 * @param cont_column_names     an array contains all the continuous feature
 *                              null means no continuous feature
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param h2hmv_routine_id      the id of the routine which specifies 
                                how to handle missing value(h2hmv)
 * @param verbosity             ture if print the debug info 
 *
 * @note The name convension of the table for a column is: metatable_name || '_' || col_index 
 *       col_index is start from 1, and end at 9999 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    feature_names       TEXT[],
    class_column_name   TEXT, 
    cont_column_names   TEXT[], 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    feature_names       TEXT[],
    class_column_name   TEXT, 
    cont_column_names   TEXT[], 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    column_name         TEXT :='';
    curstmt             TEXT := '';
    result_rec          RECORD;
    col_index           INT := 1;
    contcol_stmt        TEXT := '';
    contcol_stmt_quote  TEXT := '';
    coltable_name       TEXT := rtrim(metatable_name, 'di');
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();
    
    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_table_name,
            feature_names,
            id_column_name,
            class_column_name
        );
        
    PERFORM MADLIB_SCHEMA.__create_metatable(metatable_name);
    
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            contcol_stmt_quote = contcol_stmt_quote || quote_literal(cont_column_names[i]) || ',';
            contcol_stmt = contcol_stmt || ',' || cont_column_names[i];
        END LOOP; 
    END IF;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    contcol_stmt_quote = contcol_stmt_quote || '''' || id_column_name || '''';

    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            PERFORM MADLIB_SCHEMA.__encode_cont_column
                (
                    input_table_name, 
                    id_column_name, 
                    cont_column_names[i],
                    coltable_name || col_index,
                    encoded_table_name,
                    metatable_name,
                    h2hmv_routine_id,
                    't',
                    verbosity
                );
            
            col_index = col_index + 1;
        END LOOP; 
    END IF;
         
    IF (feature_names IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT btrim(attname, '' '') as attname 
             FROM   pg_attribute 
             WHERE  attrelid = ''%''::regclass and attnum > 0 AND 
                    (attname NOT IN (%)) AND 
                    NOT attisdropped;', 
            input_table_name, contcol_stmt_quote)
            INTO curstmt;   
        
        FOR column_name IN EXECUTE curstmt LOOP
            
            IF (column_name <> class_column_name) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                
                col_index = col_index + 1;
            END IF;
        END LOOP;
    ELSE
        FOR i IN 1..array_upper(feature_names, 1) LOOP
            column_name = feature_names[i];
            IF (NOT MADLIB_SCHEMA.__is_continuous(column_name, cont_column_names)) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index ,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                    
                col_index = col_index + 1;
            END IF;    
        END LOOP;
    END IF;
    
    -- class column
    PERFORM MADLIB_SCHEMA.__encode_class_column
        (
            input_table_name, 
            id_column_name, 
            class_column_name,
            coltable_name || col_index,
            encoded_table_name,
            metatable_name,
            't',
            verbosity
        ) ;

    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            't'
        );
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;    

/*
 * @brief Encode a tabular table for classification/scoring
 * @param input_table_name the input table name
 * @param encoded_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param h2hmv_routine_id the id of the routine which specifies 
                            how to handle missing value(h2hmv) 
 * @param verbosity ture if print the debug info 
 *
 * @note  feature (discrete or continuous) names and keys were retrieved from meta table
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt             TEXT;
    id_column_name      TEXT;
    temp                TEXT := '';
    result_rec          RECORD;
    contcol_stmt        TEXT := '';
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();

    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_table_name
        );
                
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name FROM MADLIB_SCHEMA.% WHERE column_type=''i'';',
        metatable_name)
        INTO curstmt; 
    
    EXECUTE curstmt INTO id_column_name;
    
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name, table_name FROM MADLIB_SCHEMA.% WHERE is_cont ORDER BY id;',
        metatable_name)
        INTO curstmt; 
        
    FOR result_rec IN EXECUTE curstmt LOOP
        contcol_stmt = contcol_stmt || ',' || result_rec.column_name;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    FOR result_rec IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__encode_cont_column
            (
                input_table_name, 
                id_column_name, 
                result_rec.column_name,
                result_rec.table_name,
                encoded_table_name,
                metatable_name,
                h2hmv_routine_id,
                'f',
                verbosity
            );
    END LOOP;
        
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name, column_type, table_name 
          FROM   MADLIB_SCHEMA.% 
          WHERE  (column_type <> ''i'') AND (NOT is_cont) ORDER BY id',
        metatable_name)
        INTO curstmt; 
                
    FOR result_rec IN EXECUTE curstmt LOOP
        IF (result_rec.column_type = 'f') THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        'f',
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        'f',
                        verbosity
                    );
        ELSIF (result_rec.column_type = 'c') THEN
                PERFORM MADLIB_SCHEMA.__encode_class_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        'f',
                        verbosity
                    );
        ELSE
            -- nothing need to do for id column
        END IF;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            'f'
        );
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;
   
   
/*
 * @brief The post process for encoding
 *
 * @param id_column_name the name of id column 
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 *
 * @return the string contains the drop column statement   
 *
 */   
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name      TEXT,
    metatable_name      TEXT,
    is_persistent       BOOLEAN
    ) CASCADE;
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name      TEXT,
    metatable_name      TEXT,
    is_persistent       BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
BEGIN
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, id_column_name, 'i', 'f', '', 0);
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Create the encoding table
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param contcol_stmt a string contains all the continuous feature names 
 *                    with delimiter ','
 * @param encoded_table_name the encoding table name
 * @param verbosity ture if print the debug info 
 *
 * @return the encoding table name  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_encoded_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    contcol_stmt        TEXT,
    encoded_table_name  TEXT,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_encoded_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    contcol_stmt        TEXT,
    encoded_table_name  TEXT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    rec     RECORD;
BEGIN

    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(encoded_table_name)) <= 63, 
            'The maximum length of ' || encoded_table_name || ' is 63'
        );
        
        
    IF (verbosity) THEN
        RAISE INFO 'continuous columns:%', contcol_stmt;
    END IF;
    
    -- create result table, and get all the id and continuous columns' value
    EXECUTE 'DROP TABLE IF EXISTS ' || encoded_table_name || ' CASCADE;';
    
    SELECT MADLIB_SCHEMA.__format(
        'CREATE TABLE %(id %) AS SELECT % % FROM % m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY(id)');', 
        ARRAY[
            encoded_table_name, 
            contcol_stmt, 
            id_column_name, 
            contcol_stmt, 
            input_table_name
            ])
        INTO curstmt;
            
    EXECUTE curstmt;
     
    RETURN  encoded_table_name ;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the continuous feature
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param column_name           name of the column
 * @param coltable_name         the table name for the specified column
 *                              this table is used to store the minimal value of this column
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param h2hmv_routine_id      the id of the routine which specifies 
                                how to handle missing value(h2hmv)
 * @param is_persistent         ture if write the column info into meta table
 * @param verbosity             ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_cont_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    h2hmv_routine_id        INT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_cont_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    h2hmv_routine_id        INT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt         TEXT := '';
    num             INT := 0;
    min_val         FLOAT8;
    coltable_name2  TEXT := coltable_name;
BEGIN
    -- insert the continuous features
    IF (is_persistent) THEN
        IF (h2hmv_routine_id = 2) THEN
            SELECT MADLIB_SCHEMA.__format(
                'SELECT coalesce(min(%), 1) - 1 FROM %', 
                column_name,
                input_table_name) 
                INTO curstmt;
                
            EXECUTE curstmt INTO min_val;
    
            SELECT MADLIB_SCHEMA.__format(
                'CREATE TABLE MADLIB_SCHEMA.%(key) AS SELECT % m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (key)')', 
                coltable_name2,
                MADLIB_SCHEMA.__to_char(min_val)) 
                INTO curstmt;
                
            EXECUTE curstmt;
                    
            SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=% WHERE % is null;',
                          encoded_table_name,
                          column_name,
                          MADLIB_SCHEMA.__to_char(min_val),
                          column_name)
                 INTO curstmt;
                 
            EXECUTE curstmt;
        ELSE
            coltable_name2 = '';
        END IF;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT COUNT(DISTINCT %) FROM %',
            column_name, input_table_name)
            INTO curstmt;
        
        EXECUTE curstmt INTO num;
        
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, 'f', 't', coltable_name2, num);
    ELSE
         IF (h2hmv_routine_id = 2) THEN
             SELECT MADLIB_SCHEMA.__format(
                'SELECT key FROM MADLIB_SCHEMA.% LIMIT 1', 
                coltable_name2) 
                INTO curstmt;
                
            EXECUTE curstmt INTO min_val;
            
            SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=% WHERE % is null',
                          encoded_table_name,
                          column_name,
                          MADLIB_SCHEMA.__to_char(min_val),
                          column_name)
                 INTO curstmt;
                 
            EXECUTE curstmt;
        END IF;
        
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the class column
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param column_name           name of the column
 * @param coltable_name         the table name for the specified column
 *                              this table is the key-value table for this column
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param is_persistent         ture if write the column info into meta table
 * @param verbosity             ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_class_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_class_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt     TEXT := '';
    column_type CHAR := 'c';
    n           INT;
BEGIN
    
    IF (
        NOT MADLIB_SCHEMA.__column_exists
                    (
                    input_table_name,
                    column_name
                    ) 
       ) THEN
        
        RETURN;
        
    END IF;
                
    SELECT MADLIB_SCHEMA.__format
            (
            'SELECT COUNT(*) 
             FROM %
             WHERE % IS NULL',
            input_table_name,
            column_name
            )
    INTO curstmt;
    
    EXECUTE curstmt INTO n;
    
    PERFORM MADLIB_SCHEMA.__assert
            (
                n = 0,
                'class column must not have NULL value'
            );    
            
    PERFORM MADLIB_SCHEMA.__encode_discrete_column
    (
        input_table_name, 
        id_column_name, 
        column_name,
        column_type,
        coltable_name,
        encoded_table_name,
        metatable_name,
        1,
        is_persistent,
        verbosity
    );
    
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format
            ('INSERT INTO MADLIB_SCHEMA.% VALUES(null, null)',
            coltable_name)
        INTO curstmt;
       
        EXECUTE curstmt;
    END IF;
    
    -- rename the class column with "class"
    IF ((column_name IS NOT NULL) AND (column_name <> '') AND (column_name <> 'class')) THEN
        SELECT MADLIB_SCHEMA.__format
            ('ALTER TABLE % RENAME % to class', encoded_table_name, column_name) 
            INTO curstmt;
        
        EXECUTE curstmt;
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the discrete column
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param column_name           name of the column
 * @param column_type           the type of column
 *                              'i' means id, 'c' means class, 'f' means feature
 * @param coltable_name         the table name for the specified column
 *                              this table is the key-value table for this column
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param h2hmv_routine_id      the id of the routine which specifies how to handle missing value(h2hmv) 
 * @param is_persistent         ture if write the column info into meta table
 * @param verbosity             ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_discrete_column
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    column_type         CHAR,
    coltable_name       TEXT,
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    is_persistent       BOOLEAN,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_discrete_column
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    column_type         CHAR,
    coltable_name       TEXT,
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    is_persistent       BOOLEAN,
    verbosity           BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
    index   INT := 1;
    name    TEXT := '';
    temp    TEXT;
BEGIN
    -- For each column, we will create a table for it. 
    -- The table stores the key->value, and distributed by value for parallelism                            
    IF (is_persistent) THEN
        EXECUTE 'DROP TABLE IF EXISTS MADLIB_SCHEMA.' || coltable_name || ';';
                
        -- create table with columns: key, value
        SELECT MADLIB_SCHEMA.__format(
            'CREATE TABLE MADLIB_SCHEMA.% (%, key)  
            AS SELECT DISTINCT %, 1 FROM %   
            m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY(%)');', 
            ARRAY[
            coltable_name, 
            column_name,
            column_name, 
            input_table_name
            m4_ifdef(`__GREENPLUM__', `, column_name')
            ]) 
            INTO curstmt;
        
        IF (verbosity) THEN    
            RAISE INFO 'Create table: %', curstmt;
        END IF;
        EXECUTE curstmt;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% ORDER BY %',
            column_name,
            coltable_name,
            column_name)
            INTO curstmt;
            
       index = 1;
       FOR name IN EXECUTE (curstmt) LOOP
            IF ((name IS null) OR (name = '?') OR (length(btrim(name, ' ')) = 0)) THEN
                temp = 'null';
                IF (h2hmv_routine_id = 2) THEN
                    temp = MADLIB_SCHEMA.__to_char(index);
                    index = index + 1;
                END IF;
                
                IF (name IS NULL) THEN
                    SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.%  SET key=% WHERE % IS NULL',
                    coltable_name, temp, column_name)
                    INTO curstmt;
                ELSE
                    SELECT MADLIB_SCHEMA.__format(
                        'UPDATE MADLIB_SCHEMA.% SET key = % WHERE %=''%'';',
                        coltable_name,
			             temp,
                        column_name,
                        name)
                        INTO curstmt;
                END IF;
		
		      EXECUTE curstmt;
		      
            ELSE
                -- we call "replace" function twice to escape the string "'" and "\" 
                SELECT MADLIB_SCHEMA.__format
                    (
                    'UPDATE MADLIB_SCHEMA.% SET key=% WHERE %=E''%'';',
                    coltable_name,
                    MADLIB_SCHEMA.__to_char(index),
                    column_name,
                    replace(replace(name, '''', ''''''), E'\\', E'\\\\')
                    )
                    INTO curstmt;
                index = index + 1;
                
            END IF;
            
            EXECUTE curstmt;
        END LOOP;
    END IF;
    

    -- We impose a hard limit, which is 8 million, on the number of distinct classes.
    -- This should be a large enough number for real world applications.
    IF ((column_type = 'c') AND (index > 8000000)) THEN
        RAISE EXCEPTION '%', 'The number of distinct class values can''t exceed 8,000,000!';
    END IF;
    
    -- Add the column to the result table
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % ADD COLUMN % INT', encoded_table_name, column_name)
            INTO curstmt;
    EXECUTE curstmt;
    
    SELECT MADLIB_SCHEMA.__update_discrete_column_table_stmt
        (
            input_table_name, 
            id_column_name, 
            column_name,
            coltable_name,
            encoded_table_name
        ) 
    INTO curstmt;
             
    IF (verbosity) THEN    
        RAISE INFO 'update stmt: %', curstmt;
    END IF;
    
    EXECUTE curstmt;     
    
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, column_type, 'f', coltable_name, index - 1);
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Retrieve the update encoding statement for discrete column
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param column_name           name of the discrete column
 * @param coltable_name         the table name for the specified column
 *                              this table is the key-value table for this column
 * @param encoded_table_name    the encoding table name
 *
 * @return the update statement
 *
 * @note Since Greenplum4.0 doesn't support to distribute data between segments when updating,
 *       we will use a temp table to store the result of joining (join column is not the distribute column)
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__update_discrete_column_table_stmt
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    coltable_name       TEXT,
    encoded_table_name  TEXT
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__update_discrete_column_table_stmt
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    coltable_name       TEXT,
    encoded_table_name  TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT    := '';
    from_stmt TEXT  := '';
BEGIN
m4_changequote(`>>>', `<<<')
m4_ifdef(>>>__GREENPLUM_PRE_4_1__<<<, >>>
    EXECUTE 'DROP TABLE IF EXISTS c45_update_discrete_col_table';
    -- use a temp table to store the result of joining
    SELECT MADLIB_SCHEMA.__format
        ('CREATE TEMP TABLE c45_update_discrete_col_table(id, key) AS
          SELECT % as id, key
          FROM % t LEFT JOIN MADLIB_SCHEMA.% k ON (t.% = k.% OR (t.% IS NULL AND k.% IS NULL))
          DISTRIBUTED BY (id)',
          ARRAY[
           id_column_name,
           input_table_name,
           coltable_name,
           column_name,
           column_name,
           column_name,
           column_name
          ]
         )
     INTO curstmt;
     
     EXECUTE curstmt;       
     
    SELECT MADLIB_SCHEMA.__format
            (
                'FROM c45_update_discrete_col_table s
                 WHERE %.id = s.id',
                 ARRAY[
                 encoded_table_name
                 ]
            )
    INTO from_stmt;          
<<<, >>>
    SELECT MADLIB_SCHEMA.__format
                ('FROM MADLIB_SCHEMA.% s, % p 
                  WHERE (s.% = p.% OR (s.% is NULL AND p.% is NULL)) AND %.id=p.%',
                  ARRAY[
                  coltable_name,
                  input_table_name,
                  column_name,
                  column_name,
                  column_name,
                  column_name,
                  encoded_table_name,
                  id_column_name]
                 )
    INTO from_stmt;    
<<<)
m4_changequote(>>>`<<<, >>>'<<<)
    
    -- the update result table statement
    SELECT MADLIB_SCHEMA.__format
                    ('UPDATE % SET %=s.key 
                      %',
                      ARRAY[
                      encoded_table_name,
                      column_name,
                      from_stmt
                      ]
                     )
    INTO curstmt;
             
    RETURN curstmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert a string with delimiter ',' to an array 
 * @param csv_str a string with delimiter ','
 *
 * @return the splitting string array    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__csvstr_to_array
    (
    csv_str TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__csvstr_to_array 
    (
    csv_str TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret     TEXT[];
    str_val TEXT;
    index   INTEGER;
BEGIN
    ret = string_to_array(lower(csv_str), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = lower(btrim(ret[index], ' '));
        END LOOP;
    END IF;

    RETURN ret;
END
$$ LANGUAGE PLPGSQL;
