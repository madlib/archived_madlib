m4_include(`SQLCommon.m4')

/* Own macro definitions */
m4_ifelse(
    m4_eval(
        m4_ifdef(`__GREENPLUM__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ * 100 + __DBMS_VERSION_MINOR__ < 401
    ), 1,
    `m4_define(`__GREENPLUM_PRE_4_1__')'
)

/*
 * @brief Cast any value to text.
 *
 * @param val	A value with any specific type.
 *
 * @return The text format string for the value.
 *
 * @note Greenplum doesn't support boolean to text casting.
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val anyelement
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val anyelement
    )
RETURNS TEXT AS $$
DECLARE
    is_bool BOOLEAN;
BEGIN
    IF (val is NULL) THEN
        return 'null'::text;
    END IF;
    SELECT pg_typeof(val) = 'boolean'::regtype INTO is_bool;
    IF (is_bool) THEN
         IF (val::boolean) THEN
            RETURN 'true';
         ELSE
            RETURN 'false';
         END IF;
    END IF;
    
    RETURN val::TEXT;

END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Cast regclass to text. we will not create a cast, 
 *        since it may override the existing cast. 
 *        Although there is no cast for regclass to text,
 *        PL/PGSQL can coerce it to text automatically.
 *        Another implementation can use sql function:
 *        select textin(regclassout('pg_class'::regclass));
 *        
 * @param rc	The regclass of the table.
 *
 * @return The text representation for the regclass.
 *
 */
CREATE or replace FUNCTION MADLIB_SCHEMA.__regclass_to_text
    (
    rc regclass
    ) 
RETURNS TEXT                          
AS $$  
BEGIN                
   RETURN rc;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Format a string with the value in args array.
 *
 * @param fmt	The format string.
 * @param args	The specified elements in format string.
 *
 * @return The formated string.
 *
 * @note Each '%' in fmt will be replaced with the corresponding value of args.
 *       The number of '%'s should equal to the length of array args.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt     TEXT, 
    args    TEXT[]
    ) 
RETURNS TEXT
AS 'MODULE_PATHNAME', 'dt_text_format'
LANGUAGE C IMMUTABLE;


/*
 * @brief Short form to format a string with four parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 * @param arg3	The third argument.
 * @param arg4	The fouth argument.
 *   
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt       TEXT, 
    arg1      TEXT, 
    arg2      TEXT, 
    arg3      TEXT,
    arg4      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2, arg3, arg4]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with three parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 * @param arg3	The third argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT, 
    arg2        TEXT, 
    arg3        TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2, arg3]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with two parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT, 
    arg2        TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with a parameter.
 *
 * @param arg1	The first argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Raise exception if the condition is false.
 *
 * @param condition		The assert condition.
 * @param reason		The reason string displayed when assert failure.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Test if the specified table exists or not.
 *
 * @param full_table_name	The full table name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    full_table_name    TEXT
    ) 
RETURNS BOOLEAN AS 
'MODULE_PATHNAME', 'table_exists' 
LANGUAGE C IMMUTABLE;


/*
 * @brief Test if the specified column exists or not.
 *
 * @param full_table_name	The full table name.
 *
 * @return True if the column exists, otherwise return false.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__column_exists
    (
    full_table_name   TEXT,
    column_name       TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curstmt         TEXT := '';
    result          INT  := 0;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            (full_table_name IS NOT NULL) AND (column_name IS NOT NULL), 
            'the table name and column name must not be null'
        );
                
    IF (MADLIB_SCHEMA.__table_exists(full_table_name)) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT COUNT(*) 
                 FROM pg_catalog.pg_attribute 
                 WHERE attnum > 0 AND 
                       (NOT attisdropped) AND
                       attname = ''%'' AND
                       attrelid = ''%''::regclass',
                ARRAY[
                    column_name,
                    full_table_name
                ]
            ) INTO curstmt;
            
        EXECUTE curstmt INTO result;
        
        RETURN result >= 1;         
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Assert if the specified table exists or not.
 *
 * @param full_table_name	The full table name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert_table
    (
    full_table_name      TEXT,
    existence            BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    err_msg     TEXT;
BEGIN
    IF (existence) THEN
        err_msg = 'assertion failure. Table: ''' || full_table_name || 
                  ''' does not exist';
    ELSE
        err_msg = 'assertion failure. Table: ''' || full_table_name || 
                  ''' already exists';
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert
        (
            MADLIB_SCHEMA.__table_exists(full_table_name) = existence, 
            err_msg
        );
END
$$ LANGUAGE PLPGSQL;

/*
 * This is a global table to store information for various tree training.
 *
 *   classifier_name             The name of the classifier, e.g, 'C4.5' or 'RF'.
 *   result_table_oid            The OID of the result table.
 *   training_table_oid          The OID of the training table.
 *   training_metatable_oid      The OID of the metadata table.
 *   training_encoded_table_oid  The OID of the encoded table.
 *   validation_table_oid        The OID of the validation table.
 *   how2handle_missing_value    The approach name to handle missing value.
 *   split_criterion             The name of the split criterion for this training.
 *   sampling_percentage         The sampling percentage for training each tree.
 *   num_feature_chosen          The number of features will be chosen to find best split.
 *   num_trees                   The number of trees will be grow in training.
 *
 */
DROP TABLE IF EXISTS MADLIB_SCHEMA.training_info;
CREATE TABLE MADLIB_SCHEMA.training_info
    (
    classifier_name             TEXT NOT NULL,
    result_table_oid            OID NOT NULL,
    training_table_oid          OID,
    training_metatable_oid      OID,
    training_encoded_table_oid  OID,
    validation_table_oid        OID,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT,
    sampling_percentage         FLOAT,
    num_feature_chosen          INT,
    num_trees                   INT,
    PRIMARY KEY (result_table_oid)
    ) m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (result_table_oid)');
GRANT SELECT, INSERT, UPDATE, DELETE ON MADLIB_SCHEMA.training_info TO PUBLIC;


/*
 * @brief Get the meta table name by the tree table name. 
 *
 * @param tree_table    The full name of the tree table.
 * 
 * @return The full name of the metatable.
 *
 */      
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    metatable_name TEXT := '';
BEGIN

    PERFORM MADLIB_SCHEMA.__assert_table
            (
                tree_table::TEXT,
                't'::BOOL
            );     
    
    PERFORM MADLIB_SCHEMA.__assert_table
            (
                'MADLIB_SCHEMA.training_info'::TEXT,
                't'::BOOL
            ); 
            
    SELECT MADLIB_SCHEMA.__regclass_to_text(training_metatable_oid) 
    FROM MADLIB_SCHEMA.training_info 
    WHERE result_table_oid = tree_table::regclass 
    INTO metatable_name;
    
    RETURN metatable_name;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class table name by the metatable name.
 *
 * @param metatable_name    The full name of the metatable.
 *
 * @return The name of the class table
 *
 */  
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_classtable_name
    (
    metatable_name TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    classtable_name TEXT;
BEGIN

    PERFORM MADLIB_SCHEMA.__assert_table
            (
                metatable_name,
                't'
            ); 
            
    EXECUTE ' SELECT MADLIB_SCHEMA.__regclass_to_text
                (table_oid) as table_name 
              FROM ' || metatable_name ||
            ' WHERE column_type = ''c'';'  
    INTO classtable_name;
    
    RETURN classtable_name;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the encoding table name by tree table name. 
 *
 * @param tree_table    The full name of the tree table.
 *
 * @return The full name of the encoded table.
 *
 */  
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    encoded_table_name TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__regclass_to_text(training_encoded_table_oid) 
    FROM MADLIB_SCHEMA.training_info
    WHERE result_table_oid = tree_table::regclass 
    INTO encoded_table_name;
    
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the unknown values processing routine id. 
 *
 * @param tree_table    The full name of the tree table.
 *
 * @return The encoded missing value processing routine id.
 *
 */     
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
DECLARE
    name TEXT;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
    (
        'MADLIB_SCHEMA.training_info',
        't'
    );
        
    SELECT how2handle_missing_value 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  result_table_oid = tree_table::regclass 
    INTO   name;
        
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSIF (name = 'explicit') THEN
        RETURN 2;
    ELSE
        RAISE EXCEPTION '__get_routine_id: %', name; 
    END IF;
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Remove the trained tree from training info table. 
 *
 * @param tree_table    The full name of the tree table.
 *
 */      
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    ) 
RETURNS void AS $$
BEGIN
    DELETE FROM MADLIB_SCHEMA.training_info 
    WHERE result_table_oid = tree_table::regclass;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert the trained tree into training info table. 
 *
 * @param classifier_table_name         The name of the classifier.
 * @param result_table_name             The full name of the training result table.
 * @param training_table_name           The full name of the training table.
 * @param training_metatable_name       The full name of metatable.
 * @param training_encoded_table_name   The full name of the encoded table. 
 * @param validation_table_name         The full name of the validation table.
 * @param how2handle_missing_value      The name of the routine to process unknown values.
 * @param split_criterion               The name of split criterion.
 * @param sampling_percentage           The percentage of bootstrap samples size in 
 *                                      training dataset.
 * @param num_features_chosen           The number of features to split on each tree node. 
 * @param num_trees                     The number of trees after completed the 
 *                                      training process.
 * 
 */ 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_traininginfo
    (
    classifier_table_name       TEXT,
    result_table_name           TEXT,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT,
    sampling_percentage         FLOAT,
    num_features_chosen         INT,
    num_trees                   INT
    )
RETURNS void AS $$
BEGIN
    INSERT INTO MADLIB_SCHEMA.training_info VALUES
        (
            classifier_table_name,
            result_table_name::regclass,
            training_table_name::regclass,
            training_metatable_name::regclass,
            training_encoded_table_name::regclass,
            validation_table_name::regclass,
            how2handle_missing_value,
            split_criterion,
            sampling_percentage,
            num_features_chosen,
            num_trees
        );
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief  Strip the schema name from the full table name.
 *
 * @param full_table_name   The full table name. 
 *
 * @return The table name without schema name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_table_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
BEGIN
     PERFORM MADLIB_SCHEMA.__assert
        (
            full_table_name IS NOT NULL, 
            'table name should not be null'
        );


    str_val = trim(both ' ' FROM split_part(full_table_name, '.', 2));

    IF (length(str_val) = 0) THEN
        str_val = btrim(full_table_name, ' ');
    END IF;

    RETURN lower(str_val);
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the schema name from a full table name.
 *        if there is no schema name in the full table name, then
 *        if the table exists, we return the schema name from catalog
 *        else the current schema name,
 *        else return the schema name from the full table name directly.
 *
 * @param full_table_name   The full table name.
 *
 * @return The schema name of the table.
 *
 */       
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_table_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    table_name          TEXT;
    temp                TEXT[];
    len                 INT;
    curstmt             TEXT;
    schema_name         TEXT;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            full_table_name IS NOT NULL, 
            'table name should not be null'
        );

    temp = string_to_array(full_table_name, '.');
    len = array_upper(temp, 1);

    IF (1 = len) THEN
        -- if table exists, return the schema name from catalog
        IF (MADLIB_SCHEMA.__table_exists(full_table_name)) THEN
            SELECT nspname 
            FROM pg_catalog.pg_namespace n
            WHERE n.oid = 
             (
                 SELECT relnamespace FROM pg_catalog.pg_class
                 WHERE oid= full_table_name::regclass
             )
                         
            INTO schema_name; 
        ELSE
            -- get the current schema name
            schema_name = current_schema();
        END IF;
    ELSE
        PERFORM MADLIB_SCHEMA.__assert
            (
                len = 2, 
                'wrong full table name<' || full_table_name || '>'
            );
        -- get the shema name directly 
        schema_name = lower(btrim(temp[1], ' '));    
    END IF;
    
    RETURN schema_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Drop the metatable and all the KV tables.
 *
 * @param metatable_name    The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    metatable_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    name    TEXT;
BEGIN
    IF (metatable_name is NULL ) THEN
        RETURN;
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert_table(metatable_name, 't');
    
    SELECT MADLIB_SCHEMA.__format
            (
            'SELECT MADLIB_SCHEMA.__regclass_to_text
                (table_oid) as table_name 
             FROM % 
             WHERE table_oid IS NOT NULL',
             metatable_name
            ) INTO curstmt;
        
    FOR name IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__assert_table(name, 't');
        EXECUTE 'DROP TABLE ' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE ' || metatable_name || ' CASCADE;';
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create the metatable. 
 *
 * @param metatable_name    The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    metatable_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(metatable_name)) <= 63, 
            'The maximum length of '                            ||
             MADLIB_SCHEMA.__strip_schema_name(metatable_name)  || 
             ' is 63'
        );
        
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert_table(metatable_name, 'f');
    
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    EXECUTE 'CREATE TABLE '|| metatable_name || E'(
        id SERIAL,
        column_name TEXT,
        column_type CHAR,    
        is_cont BOOLEAN,     
        table_oid OID,
        num_dist_value INT
    ) m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)');';
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert a record to the metatable
 *        A row in the metatable represents a column's information.
 *
 * @param metatable_name    The full name of the metatable.
 * @param column_name       The name of the column.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param is_cont           True if the column is continuous.
 * @param table_name        The full name of key-value table for the column.
 *                          The OID of this table will be stored.
 * @param num_dist_value    The number of distinct values for the column.
 *
 * @note  The null value will be included in the distinct values.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    metatable_name      TEXT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT         
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert(
        column_type = 'f' OR column_type = 'i' OR column_type = 'c',
        'column type must be ''f'', ''i'' or ''c''');
    
    IF (table_name IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'INSERT INTO % VALUES
                    (default, ''%'', ''%'', ''%'', null::regclass, %);',
                ARRAY[
                    metatable_name, 
                    column_name, 
                    column_type, 
                    MADLIB_SCHEMA.__to_char(is_cont), 
                    MADLIB_SCHEMA.__to_char(num_dist_value)
            ]) INTO curstmt;    
    ELSE
        SELECT MADLIB_SCHEMA.__format
            (
                'INSERT INTO % VALUES
                    (default, ''%'', ''%'', ''%'', ''%''::regclass, %);',
                ARRAY[
                metatable_name, 
                column_name, 
                column_type, 
                MADLIB_SCHEMA.__to_char(is_cont), 
                table_name, 
                MADLIB_SCHEMA.__to_char(num_dist_value)
                ]
            ) INTO curstmt;    
    END IF;
 
    EXECUTE curstmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct values for the feature with given ID.
 *
 * @param metatable_name    The full name of the metatable.
 * @param feature_id        The ID of the feature in the metatable.
 *
 * @return The number of the distinct values for the given feature.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    metatable_name  TEXT,
    feature_id      INT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt     TEXT := '';
    result      INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT num_dist_value 
            FROM % WHERE column_type=''f'' AND id = %;',
            metatable_name,
            MADLIB_SCHEMA.__to_char(feature_id)
        ) INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of features.
 *
 * @param metatable_name    The full name of the metatable.
 *
 * @return The number of features in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(*) 
        FROM % WHERE column_type=''f'';',
        metatable_name
        ) INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct class values.
 *
 * @param metatable_name    The full name of the metatable.
 *
 * @return The number of class labels in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt             TEXT := '';
    result              INT4 := 0;
    class_table_name    TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT MADLIB_SCHEMA.__regclass_to_text(table_oid) 
             FROM % WHERE column_type=''c'';',
            metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO class_table_name;
    
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT COUNT(key)
             FROM %',
            class_table_name
        ) INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature ID by the specified feature name.
 *
 * @param feature_name      The name of the feature.
 * @param metatable_name    The full name of the metatable.
 *
 * @return The feature ID.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    feature_name    TEXT,
    metatable_name  TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    curstmt = MADLIB_SCHEMA.__format
                (
                    'SELECT id 
                     FROM  % 
                     WHERE column_name=''%'' AND 
                           column_type = ''f'' 
                     LIMIT 1;',
                    ARRAY[
                        metatable_name,
                        feature_name
                    ]
                );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature name by the specified feature ID.
 *
 * @param feature_index     The ID of the feature.
 * @param metatable_name    The full name of the metatable.
 *
 * @return The feature name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index   INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  id = % AND column_type = ''f'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(feature_index)
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature name list.
 *
 * @param metatable_name	The full name of the metatable.
 *
 * @return The feature name list 'ARRAY[c1, c2, ..., cn]'.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_list    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := 'ARRAY[';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   ' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',') || ']';
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Concat all the feature names with delimeter ','.
 *
 * @param metatable_name	The full name of the metatable.
 *
 * @return The text representing feature names with delimeter ','.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_in_selectstmt    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := '';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   ' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',');
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the column value by the specified column ID and key.
 *
 * @param column_index      The ID of the column.
 * @param key               The key of the column value.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param metatable_name    The full name of the metatable.
 * 
 * @return The column's value corresponding to the give key. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index    INT,
    key             INT,
    column_type     CHAR,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curstmt     TEXT;
    names       TEXT[];
    result      TEXT := '';
BEGIN
    IF (column_type = 'c') THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT ARRAY[
                            column_name, 
                            MADLIB_SCHEMA.__regclass_to_text(table_oid)
                        ] 
                 FROM % 
                 WHERE  column_type = ''c'';',
                metatable_name
            ) INTO curstmt; 
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[
                        column_name, 
                        MADLIB_SCHEMA.__regclass_to_text(table_oid)
                    ] 
             FROM % 
             WHERE id = % AND column_type = ''%'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(column_index),
            column_type
            ) INTO curstmt;    
    END IF;
                   
    EXECUTE curstmt INTO names;
    
    PERFORM MADLIB_SCHEMA.__assert(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.__assert(names[2] IS NOT NULL, 'No such table name');
    
    IF (key IS NULL ) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT % FROM % WHERE key IS NULL;',
                names[1],
                names[2]
            ) INTO curstmt;        
    ELSE
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT MADLIB_SCHEMA.__to_char(%) 
                FROM % 
                WHERE key = %;',
                names[1],
                names[2],
                MADLIB_SCHEMA.__to_char(key)
            ) INTO curstmt;
    END IF;

    EXECUTE curstmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature value by the specified feature ID and key.
 *
 * @param feature_index     The ID of the feature.
 * @param key               The key of the feature value.
 * @param metatable_name    The full name of the metatable.  
 *
 * @return The value of specified key of the feature 
 *         whose id specified in feature_index.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index   INT,
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value
            (feature_index, key, 'f', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the ID column name.
 *
 * @param metatable_name	The full name of the metatable.
 *
 * @return The ID column name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_id_column_name    
    (
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
        (
            metatable_name,
            't'
        );
        
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  column_type = ''i'' 
             LIMIT 1',
            metatable_name
        ) INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class column name.
 *
 * @param metatable_name	The full name of the metatable.
 *
 * @return The class column name. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name    
    (
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
        (
            metatable_name,
            't'
        );
        
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  column_type = ''c'' LIMIT 1',
            metatable_name
        ) INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class value by the specified key.
 *
 * @param key               The key of the class value.
 * @param metatable_name    The full name of the metatable.
 *
 * @return The class value corresponding to the key. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(0, key, 'c', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;  


/*
 * @brief Check if the input table has unsupported data type or not;
 * 		  Check if the id column of input table has duplicated value or not.
 *
 * @param full_table_name     The full table name.
 * @param feature_columns     The array including all feature names.
 * @param id_column           The name of the ID column.        
 * @param class_column        The name of the class column. 
 *
 * @return If the table has unsupported data types, then raise exception
 *         otherwise return nothing.
 *
 */    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    )
RETURNS void AS $$  
DECLARE
    rec             RECORD;
    stmt            TEXT;
    all_columns     TEXT := '';
    index           INT;
BEGIN
    -- find the first (LIMIT 1) unsupported data type if the input table has.
    stmt= 'SELECT atttypid 
    FROM pg_attribute 
    WHERE attrelid ='||quote_literal(full_table_name)||'::regclass  AND
          attnum > 0                                                AND 
          (not attisdropped)                                        AND
          atttypid NOT IN 
          (
              SELECT unnest
                    (
                        ARRAY[
                            ''SMALLINT''::regtype::oid,
                            ''INT''::regtype::oid, 
                            ''BIGINT''::regtype::oid, 
                            ''FLOAT8''::regtype::oid, 
                            ''REAL''::regtype::oid, 
                            ''NUMERIC''::regtype::oid,
                            ''DECIMAL''::regtype::oid,
                            ''INET''::regtype::oid, 
                            ''CIDR''::regtype::oid, 
                            ''MACADDR''::regtype::oid, 
                            ''BOOLEAN''::regtype::oid, 
                            ''CHAR''::regtype::oid, 
                            ''VARCHAR''::regtype::oid, 
                            ''TEXT''::regtype::oid, 
                            ''"char"''::regtype::oid, 
                            ''DATE''::regtype::oid, 
                            ''TIME''::regtype::oid,
                            ''TIMETZ''::regtype::oid, 
                            ''TIMESTAMP''::regtype::oid, 
                            ''TIMESTAMPTZ''::regtype::oid, 
                            ''INTERVAL''::regtype::oid
                        ]
                    )
          ) ';

    IF (feature_columns IS NOT NULL) THEN
        -- If user do not specify feature columns, we use all those columns.
        -- Otherwise, we just need to check those specified columns.
        index = array_lower(feature_columns, 1);
        WHILE (index <= array_upper(feature_columns, 1)) LOOP
            all_columns = all_columns                           || 
                          quote_literal(feature_columns[index]) || 
                          ',';
            index = index+1;
        END LOOP; 
        
        all_columns = all_columns || quote_literal(id_column) || ',';
        all_columns = all_columns || quote_literal(class_column);
        stmt = stmt ||' AND attname IN ('||all_columns||') ';
    END IF;
    
    stmt = stmt||' LIMIT 1;';
    
    EXECUTE stmt INTO rec;
            
    IF (rec IS NOT NULL) THEN
        -- Print the first unsupported data type, and supported types.
        RAISE EXCEPTION 'Unsupported data type [%]. Supported types include:
                         SMALLINT, INT, BIGINT, FLOAT8, REAL, NUMERIC,
                         DECIMAL, INET, CIDR, MACADDR, BOOLEAN,
                         CHAR, VARCHAR, TEXT, "char", 
                         DATE, TIME, TIMETZ, TIMESTAMP, TIMESTAMPTZ, and INTERVAL', 
                         rec.atttypid::regtype;
    END IF;

    SELECT MADLIB_SCHEMA.__format
            ('SELECT % AS n
              FROM % 
              GROUP BY %
              HAVING COUNT(%) > 1
              LIMIT 1',
              ARRAY[
                id_column,
                full_table_name,
                id_column,
                id_column
                ]
            )
    INTO stmt;
    
    EXECUTE stmt INTO rec;
    
    -- check if the id column has duplicated value
    PERFORM MADLIB_SCHEMA.__assert
                (
                    rec IS NULL,
                    'The training table ' || full_table_name || ' must not have duplicated id'
                );
                        
    RETURN;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Test if the given column is a continuous one or not.
 *
 * @param column_name           The name of the column.
 * @param cont_column_names     The array contains all the 
 *                              continuous column names.
 * 
 * @return True if the specified column is continuous, otherwise return false.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            IF (cont_column_names[i] = column_name) THEN
                RETURN 't';
            END IF;
        END LOOP; 
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode a tabular table.
 *
 * @param input_table_name      The full name of the input table.
 * @param id_column_name        The name of id column.
 * @param feature_names         An array contains all the feature. If it's null, 
 *                              we will get all the columns of the input table.
 * @param class_column_name     The name of class column.
 * @param cont_column_names     An array contains all the continuous feature.
 *                              Null means no continuous feature.
 * @param encoded_table_name    The full name of the encoded table.
 * @param metatable_name        The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies 
 *                              How to handle missing value(h2hmv).
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 * @return The full name of the encoded table.
 *
 * @note The name convension of the table for a column is:
 *       metatable_name || '_' || col_index 
 *       col_index is start from 1, and end at 9999 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    feature_names       TEXT[],
    class_column_name   TEXT, 
    cont_column_names   TEXT[], 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS TEXT AS $$
DECLARE
    column_name         TEXT :='';
    curstmt             TEXT := '';
    result_rec          RECORD;
    col_index           INT := 1;
    contcol_stmt        TEXT := '';
    contcol_stmt_quote  TEXT := '';
    
    -- the key-value tables will have the same schema with meta table
    coltable_name       TEXT := rtrim(metatable_name, 'di');
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();
    
    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_table_name,
            feature_names,
            id_column_name,
            class_column_name
        );
    
    PERFORM MADLIB_SCHEMA.__create_metatable(metatable_name);
    
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            contcol_stmt_quote = contcol_stmt_quote                  || 
                                 quote_literal(cont_column_names[i]) || 
                                 ',';
            contcol_stmt = contcol_stmt || ',' || cont_column_names[i];
        END LOOP; 
    END IF;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    contcol_stmt_quote = contcol_stmt_quote || '''' || id_column_name || '''';

    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            PERFORM MADLIB_SCHEMA.__encode_cont_column
                (
                    input_table_name, 
                    id_column_name, 
                    cont_column_names[i],
                    coltable_name || col_index,
                    encoded_table_name,
                    metatable_name,
                    h2hmv_routine_id,
                    't',
                    verbosity
                );
            
            col_index = col_index + 1;
        END LOOP; 
    END IF;
         
    IF (feature_names IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT btrim(attname, '' '') as attname 
                 FROM   pg_attribute 
                 WHERE  attrelid = ''%''::regclass and attnum > 0 AND 
                        (attname NOT IN (%)) AND 
                        NOT attisdropped;', 
                input_table_name, 
                contcol_stmt_quote
            ) INTO curstmt;   
        
        FOR column_name IN EXECUTE curstmt LOOP
            IF (column_name <> class_column_name) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                
                col_index = col_index + 1;
            END IF;
        END LOOP;
    ELSE
        FOR i IN 1..array_upper(feature_names, 1) LOOP
            column_name = feature_names[i];
            IF (NOT MADLIB_SCHEMA.__is_continuous
                (column_name, cont_column_names)
               ) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index ,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                    
                col_index = col_index + 1;
            END IF;    
        END LOOP;
    END IF;
    
    -- class column
    PERFORM MADLIB_SCHEMA.__encode_class_column
        (
            input_table_name, 
            id_column_name, 
            class_column_name,
            coltable_name || col_index,
            encoded_table_name,
            metatable_name,
            't',
            verbosity
        ) ;

    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            't'
        );
    
    IF (verbosity > 0) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Encode a tabular table for classification/scoring.
 *
 * @param input_table_name      The full name of the input table.
 * @param encoded_table_name    The full name of the encoded table.
 * @param metatable_name        The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies 
 *                              how to handle missing value(h2hmv). 
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 * @return The name of the encoded table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt             TEXT;
    id_column_name      TEXT;
    temp                TEXT := '';
    result_rec          RECORD;
    contcol_stmt        TEXT := '';
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();

    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT column_name FROM % WHERE column_type=''i'';',
            metatable_name
        ) INTO curstmt; 
    EXECUTE curstmt INTO id_column_name;
    
    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_table_name,
            NULL,
            id_column_name,
            NULL
        );
                
    SELECT MADLIB_SCHEMA.__format
        (
            'SELECT 
             column_name, 
             MADLIB_SCHEMA.__regclass_to_text(table_oid) as table_name
             FROM % WHERE is_cont ORDER BY id;',
            metatable_name
        ) INTO curstmt; 
        
    FOR result_rec IN EXECUTE curstmt LOOP
        contcol_stmt = contcol_stmt || ',' || result_rec.column_name;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    FOR result_rec IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__encode_cont_column
            (
                input_table_name, 
                id_column_name, 
                result_rec.column_name,
                result_rec.table_name,
                encoded_table_name,
                metatable_name,
                h2hmv_routine_id,
                'f',
                verbosity
            );
    END LOOP;
        
    SELECT MADLIB_SCHEMA.__format
        ('SELECT 
            column_name, 
            column_type, 
            MADLIB_SCHEMA.__regclass_to_text(table_oid) as table_name
          FROM   % 
          WHERE  (column_type <> ''i'') AND (NOT is_cont) ORDER BY id',
        metatable_name)
        INTO curstmt; 
                
    FOR result_rec IN EXECUTE curstmt LOOP
        IF (result_rec.column_type = 'f') THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        'f',
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        'f',
                        verbosity
                    );
        ELSIF (result_rec.column_type = 'c') THEN
                PERFORM MADLIB_SCHEMA.__encode_class_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        'f',
                        verbosity
                    );
        ELSE
            -- nothing need to do for id column
        END IF;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            'f'
        );
    
    IF (verbosity > 0) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;
   
   
/*
 * @brief The post processing for encoding table.
 *
 * @param id_column_name    The name of the ID column.
 * @param metatable_name    The full name of the metatable.
 * @param is_persistent     True if write the column info into the metatable.
 *
 */   
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name      TEXT,
    metatable_name      TEXT,
    is_persistent       BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
BEGIN
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, id_column_name, 'i', 'f', NULL, 0);
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create the encoded table.
 *
 * @param input_table_name      The full name of the input table.
 * @param id_column_name        The name of the ID column. 
 * @param contcol_stmt          A string contains all the continuous 
 *                              feature names with delimiter ','.
 * @param encoded_table_name    The full name of encoded table.
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 * @return The name of the encoded table.  
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_encoded_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    contcol_stmt        TEXT,
    encoded_table_name  TEXT,
    verbosity           INT
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    rec     RECORD;
BEGIN

    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(encoded_table_name)) <= 63, 
            'The maximum length of ' || encoded_table_name || ' is 63'
        );
        
        
    IF (verbosity > 0) THEN
        RAISE INFO 'continuous columns:%', contcol_stmt;
    END IF;
    
    -- create result table, and get all the id and continuous columns' value
    EXECUTE 'DROP TABLE IF EXISTS ' || encoded_table_name || ' CASCADE;';
    
    curstmt = MADLIB_SCHEMA.__format
                (
                    'CREATE TABLE %(id %) AS SELECT % % FROM % 
                    m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY(id)');', 
                    ARRAY[
                        encoded_table_name, 
                        contcol_stmt, 
                        id_column_name, 
                        contcol_stmt, 
                        input_table_name
                    ]
                );
            
    EXECUTE curstmt;
     
    RETURN  encoded_table_name;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode the continuous feature.
 *
 * @param input_table_name      The full name of the input table.
 * @param id_column_name        The name of the ID column. 
 * @param column_name           The name of the column.
 * @param coltable_name         The full table name for the specified column.
 *                              This table is used to store the minimal 
 *                              value of this column.
 * @param encoded_table_name    The full name of the encoded table.
 * @param metatable_name        The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies 
                                How to handle missing value(h2hmv).
 * @param is_persistent         True if write the column info into meta table.
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_cont_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    h2hmv_routine_id        INT,
    is_persistent           BOOLEAN,
    verbosity               INT
    ) 
RETURNS void AS $$
DECLARE
    curstmt         TEXT := '';
    num             INT := 0;
    min_val         FLOAT8;
    coltable_name2  TEXT := coltable_name;
BEGIN
    -- insert the continuous features
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT coalesce(min(%), 1) - 1 FROM %', 
                column_name,
                input_table_name
            ) INTO curstmt;
            
        EXECUTE curstmt INTO min_val;

        SELECT MADLIB_SCHEMA.__format
            (
                'CREATE TABLE %(key) AS SELECT % 
                 m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (key)')', 
                coltable_name2,
                MADLIB_SCHEMA.__to_char(min_val)
            ) INTO curstmt;
            
        EXECUTE curstmt;
                
        SELECT MADLIB_SCHEMA.__format
            (
                'UPDATE % SET %=% WHERE % is null;',
                      encoded_table_name,
                      column_name,
                      MADLIB_SCHEMA.__to_char(min_val),
                      column_name
            ) INTO curstmt;
             
        EXECUTE curstmt;
        
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT COUNT(DISTINCT %) FROM %',
                column_name, 
                input_table_name
            ) INTO curstmt;
        
        EXECUTE curstmt INTO num;
        
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, 'f', 't', coltable_name2, num);
    ELSE
         SELECT MADLIB_SCHEMA.__format
            (
                'SELECT key FROM % LIMIT 1', 
                coltable_name2
            ) INTO curstmt;
            
        EXECUTE curstmt INTO min_val;
        
        SELECT MADLIB_SCHEMA.__format
            (
                'UPDATE % SET %=% WHERE % is null',
                 encoded_table_name,
                 column_name,
                 MADLIB_SCHEMA.__to_char(min_val),
                 column_name
            ) INTO curstmt;
             
        EXECUTE curstmt;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode the class column.
 *
 * @param input_table_name      The full name of the input table.
 * @param id_column_name        The name of the ID column.
 * @param column_name           The name of the column.
 * @param coltable_name         The full table name for the specified column.
 *                              This table is the key-value table for this column.
 * @param encoded_table_name    The name of the encoded table.
 * @param metatable_name        The full name of the metatable.
 * @param is_persistent         True if write the column info into meta table.
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_class_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    is_persistent           BOOLEAN,
    verbosity               INT
    ) 
RETURNS void AS $$
DECLARE
    curstmt     TEXT := '';
    column_type CHAR := 'c';
    n           INT;
BEGIN
    
    IF (
        NOT MADLIB_SCHEMA.__column_exists
            (
                input_table_name,
                column_name
            ) 
       ) THEN
        
        RETURN;
        
    END IF;
                
    SELECT MADLIB_SCHEMA.__format
            (
            'SELECT COUNT(*) 
             FROM %
             WHERE % IS NULL',
            input_table_name,
            column_name
            )
    INTO curstmt;
    
    EXECUTE curstmt INTO n;
    
    PERFORM MADLIB_SCHEMA.__assert
            (
                n = 0,
                'class column must not have NULL value'
            );    
            
    PERFORM MADLIB_SCHEMA.__encode_discrete_column
    (
        input_table_name, 
        id_column_name, 
        column_name,
        column_type,
        coltable_name,
        encoded_table_name,
        metatable_name,
        1,
        is_persistent,
        verbosity
    );
    
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format
            ('INSERT INTO % VALUES(null, null)',
            coltable_name)
        INTO curstmt;
       
        EXECUTE curstmt;
    END IF;
    
    -- rename the class column with "class"
    IF ((column_name IS NOT NULL) AND (column_name <> '') AND 
        (column_name <> 'class')
       ) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'ALTER TABLE % RENAME % to class', 
                encoded_table_name, 
                column_name
            ) 
            INTO curstmt;
        
        EXECUTE curstmt;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode the discrete column.
 *
 * @param input_table_name      The full name of the input table.
 * @param id_column_name        The name of the ID column. 
 * @param column_name           The name of the column.
 * @param column_type           The type of column.
 *                              'i' means id, 'c' means class, 'f' means feature.
 * @param coltable_name         The full table name for the specified column.
 *                              This table is the key-value table for this column.
 * @param encoded_table_name    The full name of the encoded table. 
 * @param metatable_name        The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies how to 
 *                              handle missing value(h2hmv). 
 * @param is_persistent         True if write the column info into meta table.
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_discrete_column
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    column_type         CHAR,
    coltable_name       TEXT,
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    is_persistent       BOOLEAN,
    verbosity           INT
    ) 
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
    index   INT  := 1;
    name    TEXT := '';
    temp    TEXT;
BEGIN
    -- For each column, we will create a table for it. 
    -- The table stores the key->value, and distributed by value for parallelism                            
    IF (is_persistent) THEN
        EXECUTE 'DROP TABLE IF EXISTS ' || coltable_name || ';';
                
        -- create table with columns: key, value
        SELECT MADLIB_SCHEMA.__format
            (
                'CREATE TABLE % (%, key)  
                 AS SELECT DISTINCT %, 1 FROM %   
                 m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY(%)');', 
                ARRAY[
                    coltable_name, 
                    column_name,
                    column_name, 
                    input_table_name
                    m4_ifdef(`__GREENPLUM__', `, column_name')
                ]
            ) INTO curstmt;
        
        IF (verbosity > 0) THEN    
            RAISE INFO 'Create table: %', curstmt;
        END IF;
        EXECUTE curstmt;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM % ORDER BY %',
            column_name,
            coltable_name,
            column_name)
            INTO curstmt;
            
       index = 1;
       FOR name IN EXECUTE (curstmt) LOOP
            IF ((name IS null) OR (name = '?') OR 
                (length(btrim(name, ' ')) = 0)
               ) THEN
                temp = 'null';
                IF (h2hmv_routine_id = 2) THEN
                    temp = MADLIB_SCHEMA.__to_char(index);
                    index = index + 1;
                END IF;
                
                IF (name IS NULL) THEN
                    SELECT MADLIB_SCHEMA.__format(
                    'UPDATE %  SET key=% WHERE % IS NULL',
                    coltable_name, temp, column_name)
                    INTO curstmt;
                ELSE
                    SELECT MADLIB_SCHEMA.__format(
                        'UPDATE % SET key = % WHERE %=''%'';',
                        coltable_name,
                         temp,
                        column_name,
                        name)
                        INTO curstmt;
                END IF;
        
              EXECUTE curstmt;
            ELSE
                -- we call "replace" function twice to escape the string "'" and "\" 
                SELECT MADLIB_SCHEMA.__format
                    (
                    'UPDATE % SET key=% WHERE %=E''%'';',
                    coltable_name,
                    MADLIB_SCHEMA.__to_char(index),
                    column_name,
                    replace(replace(name, '''', ''''''), E'\\', E'\\\\')
                    )
                    INTO curstmt;
                index = index + 1;
                
            END IF;
            EXECUTE curstmt;
        END LOOP;
    END IF;

    -- We impose a hard limit, which is 8 million, on the number of distinct classes.
    -- This should be a large enough number for real world applications.
    IF ((column_type = 'c') AND (index > 8000000)) THEN
        RAISE EXCEPTION '%', 
            'The number of distinct class values can''t exceed 8,000,000!';
    END IF;
    
    -- Add the column to the result table
    SELECT MADLIB_SCHEMA.__format
        (
            'ALTER TABLE % ADD COLUMN % INT', 
            encoded_table_name, 
            column_name
        ) INTO curstmt;
    EXECUTE curstmt;
    
    SELECT MADLIB_SCHEMA.__update_discrete_column_table_stmt
        (
            input_table_name, 
            id_column_name, 
            column_name,
            coltable_name,
            encoded_table_name
        ) 
    INTO curstmt;
             
    IF (verbosity > 0) THEN    
        RAISE INFO 'update stmt: %', curstmt;
    END IF;
    
    EXECUTE curstmt;     
    
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, column_type, 
             'f', coltable_name, index - 1);
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Retrieve the update statement for discrete column.
 *
 * @param input_table_name      The full name of the input table.
 * @param column_name           The name of the discrete column.
 * @param coltable_name         The full table name for the specified column.
 *                              This table is the key-value table for this column.
 * @param encoded_table_name    The full name of the encoded table.
 *
 * @return The SQL statement for updating the discrete column.
 *
 * @note Since Greenplum4.0 doesn't support to distribute data between 
 *       segments when updating, we will use a temp table to store the 
 *       result of joining (join column is not the distribute column).
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__update_discrete_column_table_stmt
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    coltable_name       TEXT,
    encoded_table_name  TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT    := '';
    from_stmt TEXT  := '';
BEGIN
m4_changequote(`>>>', `<<<')
m4_ifdef(>>>__GREENPLUM_PRE_4_1__<<<, >>>
    EXECUTE 'DROP TABLE IF EXISTS c45_update_discrete_col_table';
    -- use a temp table to store the result of joining
    curstmt = MADLIB_SCHEMA.__format
                (
                    'CREATE TEMP TABLE 
                     c45_update_discrete_col_table(id, key) AS
                     SELECT % as id, key
                     FROM % t LEFT JOIN % k 
                        ON (t.% = k.% OR (t.% IS NULL AND k.% IS NULL))
                     m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
                     ARRAY[
                       id_column_name,
                       input_table_name,
                       coltable_name,
                       column_name,
                       column_name,
                       column_name,
                       column_name
                     ]
                 );
     EXECUTE curstmt;       
     
    from_stmt = MADLIB_SCHEMA.__format
                (
                    'FROM c45_update_discrete_col_table s
                     WHERE %.id = s.id',
                     ARRAY[
                     encoded_table_name
                     ]
                );
<<<, >>>
    from_stmt = MADLIB_SCHEMA.__format
                (
                     'FROM % s, % p 
                      WHERE (s.% = p.% OR (s.% is NULL AND p.% is NULL)) AND 
                            %.id=p.%',
                      ARRAY[
                          coltable_name,
                          input_table_name,
                          column_name,
                          column_name,
                          column_name,
                          column_name,
                          encoded_table_name,
                          id_column_name
                      ]
                 );
<<<)
m4_changequote(>>>`<<<, >>>'<<<)
    
    -- the update result table statement
    curstmt = MADLIB_SCHEMA.__format
                (
                     'UPDATE % SET %=s.key 
                      %',
                      ARRAY[
                        encoded_table_name,
                        column_name,
                        from_stmt
                      ]
                );
             
    RETURN curstmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert a string with delimiter ',' to an array.  
 *
 * @param csv_str   The string with elements delimited by ','.
 *
 * @return The splitting string array.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__csvstr_to_array 
    (
    csv_str TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret     TEXT[];
    str_val TEXT;
    index   INTEGER;
BEGIN
    ret = string_to_array(lower(csv_str), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = btrim(ret[index], ' ');
        END LOOP;
    END IF;

    RETURN ret;
END
$$ LANGUAGE PLPGSQL;

