/*
 * @brief Convert bigint to char
 * @param val Bigint value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    RETURN val::TEXT;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert float to char
 * @param val float value
 */
 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    RETURN val::TEXT;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert boolean to char
 * @param val boolean value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    IF (val) THEN
        RETURN 't';
    ELSE
        RETURN 'f';
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Format a string with the value in allvalues array
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 *       The number of '%' should be equal with the length of array allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    allvalues TEXT[]
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    allvalues TEXT[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
    parts TEXT[];
    idx INT := 1;
    curpart TEXT;
    curvalue TEXT;
BEGIN
    SELECT regexp_split_to_array(format_str, '%') INTO parts;
    
    LOOP
        curpart = parts[idx];
        curValue = allvalues[idx];
        IF (curpart IS NULL OR curValue IS NULL ) THEN
            EXIT;
        END IF;
        
        stmt = stmt || curpart || curValue;
        idx = idx + 1;
    END LOOP;
    
    IF (curpart IS NOT NULL) THEN
        stmt = stmt || curpart;
    END IF;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Short form to format a string with four parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 * @param value4 The fouth value
    
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT, 
    value3    TEXT,
    value4    TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT, 
    value3    TEXT,
    value4    TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3, value4]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with three parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT, 
    value3    TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT, 
    value3    TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with two parameters
 * @param value1 The first value
 * @param value2 The second value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT, 
    value2    TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with a parameter
 * @param value1 The first value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str TEXT, 
    value1    TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief   Format a string with the value in allvalues array
 *          All the char ('%') in format_str will be replaced with allvalues
 *          If a element in quotes is t, then the value in allvalues will be quoted.
 *          Such as, allvalues: ['1', '2'], and quotes: ['f', 't']
 *          then allvalues will be change to [''1'', ''2''] 
 *
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 * @param quotes specify which string in the array should add quote
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str   TEXT, 
    allvalues   TEXT[], 
    quotes      BOOLEAN[]
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str   TEXT, 
    allvalues   TEXT[], 
    quotes      BOOLEAN[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
    allvalues2 TEXT[];
    idx INT := 1;
    quote TEXT;
BEGIN
    LOOP
        quote = quotes[idx];
        IF (quote IS NULL) THEN
            EXIT;
        END IF;
        stmt = allvalues[idx];
        IF (quote) THEN
            SELECT quote_literal( allvalues[idx] ) INTO stmt;
        END IF;
        
        allvalues2[idx] = stmt;
        idx = idx + 1;
    END LOOP;
    
    SELECT MADLIB_SCHEMA.__format(format_str, allvalues2) INTO stmt;
    
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief assert function
 * @param condition the assert condition
 * @param reason the reason string, will be display when assert is failed
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Test if the specified table under the specified schema exists or not
 * @param schema_name schema name of the table
 * @param table_name the short table name without schema name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__table_exists
    (
    schema_name  TEXT,
    table_name   TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    schema_name  TEXT,
    table_name   TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
    result INT := 0;
    schema_name_c TEXT := '';
    table_name_c TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert(schema_name IS NOT NULL, 'Schema name must not be null!');
    PERFORM MADLIB_SCHEMA.__assert(table_name IS NOT NULL, 'Table name must not be null!');
    
    IF (length(btrim(lower(schema_name), ' ')) = 0 OR (schema_name IS NULL)) THEN
        schema_name_c = 'public';
    ELSE
        schema_name_c = schema_name;
    END IF;
    
    table_name_c = btrim(lower(table_name), ' ');
    
    SELECT MADLIB_SCHEMA.__format('SELECT count(c.oid)
        FROM pg_catalog.pg_class c
        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE btrim(c.relname, '' '') = ''%''
        AND btrim(n.nspname, '' '') = ''%'';',
        table_name_c,
        schema_name_c
        )
        INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result >= 1;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief assert if the specified table under the specified schema exists or not
 * @param schema_name schema name of the table
 * @param table_name the short table name without schema name
 * @param existence ture if assert table exists, otherwise false
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    schema_name TEXT,
    table_name TEXT,
    existence BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    schema_name TEXT,
    table_name TEXT,
    existence BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
        MADLIB_SCHEMA.__table_exists(schema_name, table_name) = existence, 
        'assert failed!'
        );
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the meta table name by the tree table name
 * @param tree_table tree table name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    metatable_name TEXT := '';
BEGIN
    SELECT training_metatable_name 
    FROM MADLIB_SCHEMA.training_info 
    WHERE tree_table_name = tree_table 
    INTO metatable_name;
    
    RETURN metatable_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the encoding table name by tree table name
 * @param tree_table tree table name
 * 
 * @return the encoding table name
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    encode_table_name TEXT := '';
BEGIN
    SELECT training_encoded_table_name 
    FROM MADLIB_SCHEMA.training_info
    WHERE tree_table_name = tree_table 
    INTO encode_table_name;
    
    RETURN encode_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the unknown values processing routine id 
 * @param tree_table tree table name         
 *  
 * @note currently, we only support 'explicit'
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
DECLARE
    name TEXT;
BEGIN
    SELECT how2handle_missing_value FROM MADLIB_SCHEMA.training_info 
        WHERE tree_table_name = tree_table INTO name;
        
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSIF (name = 'explicit') THEN
        RETURN 2;
    ELSE
        RAISE EXCEPTION '__get_routine_id: %', name; 
    END IF;
    
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the name of column containing feature
 * @param tree_table tree table name         
 *  
 * @return the name of column containing feature
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    feature_name TEXT;
BEGIN
    SELECT feature_col_names FROM MADLIB_SCHEMA.training_info 
        WHERE tree_table_name = tree_table INTO feature_name;
        
    RETURN feature_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the name of column containing class
 * @param tree_table tree table name         
 *  
 * @return the name of column containing class
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    class_name TEXT;
BEGIN
    SELECT class_col_name FROM MADLIB_SCHEMA.training_info 
        WHERE tree_table_name = tree_table INTO class_name;
        
    RETURN class_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief create the training info table 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_traininginfo
    (
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_traininginfo
    (
    ) 
RETURNS void AS $$
BEGIN
    IF ( NOT MADLIB_SCHEMA.__table_exists('MADLIB_SCHEMA', 'training_info') )THEN
        CREATE TABLE MADLIB_SCHEMA.training_info
            (
            tree_table_name TEXT NOT NULL,
            training_table_name TEXT,
            training_metatable_name TEXT,
            training_encoded_table_name TEXT,
            validation_table_name TEXT,
            how2handle_missing_value TEXT,
            PRIMARY KEY (tree_table_name)
            ) m4_ifdef(`GREENPLUM',`DISTRIBUTED BY (tree_table_name)');
    END IF;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Remove the trained tree from training info table 
 * @param tree_table tree table name 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    ) 
RETURNS void AS $$
BEGIN
    DELETE FROM MADLIB_SCHEMA.training_info WHERE tree_table_name = tree_table;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief insert the trained tree into training info table 
 * @param result_tree_table_name tree table name
 * @param training_table_name training table name
 * @param training_metatable_name name of training data table
 * @param training_encoded_table_name name of encoding table 
 * @param validation_table_name validation table name
 * @param how2handle_missing_value the routine to process unknown values
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name TEXT,
    training_table_name TEXT,
    training_metatable_name TEXT,
    training_encoded_table_name TEXT,
    validation_table_name TEXT,
    how2handle_missing_value TEXT  
    );
               
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name TEXT,
    training_table_name TEXT,
    training_metatable_name TEXT,
    training_encoded_table_name TEXT,
    validation_table_name TEXT,
    how2handle_missing_value TEXT  
    )
RETURNS void AS $$
BEGIN
    INSERT INTO MADLIB_SCHEMA.training_info VALUES
                        (
                        result_tree_table_name,
                        training_table_name,
                        training_metatable_name,
                        training_encoded_table_name,
                        validation_table_name,
                        how2handle_missing_value
                        );
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief  set the encoding table name and training data table name 
 *          in the training info table
 * @param result_tree_table_name tree table name
 * @param metatable_name name of training data table
 * @param encode_table_name name of encoded table 
 *  
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name TEXT,
    metatable_name TEXT,
    encode_table_name TEXT
    );        
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name TEXT,
    metatable_name TEXT,
    encode_table_name TEXT
    ) 
RETURNS void AS $$
BEGIN
    UPDATE MADLIB_SCHEMA.training_info 
    SET training_metatable_name = metatable_name,
        training_encoded_table_name = encode_table_name 
    WHERE tree_table_name = result_tree_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief   Strip the schema name from the full name 
 * @param full_name the full name of table (with schema name)
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
BEGIN
    str_val = trim(both ' ' from split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        str_val = trim(both ' ' from full_name);
    END IF;
    RETURN str_val;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief   get the schema name from a full database object name
 * @param full_name the fullname of a database object
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
    ret_val TEXT;
BEGIN
    str_val = trim(both ' ' from split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        ret_val = 'public';
    ELSE
        ret_val = trim(both ' ' from split_part(full_name, '.', 1));
    END IF;
    RETURN ret_val;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Drop the meta table,  
 *        Drop all the tables whose names are in 'ttable_name column
 * @param table_name the meta table name
 *
 * @note the name of parameter will be add the MADLIB_SCHEMA automatically
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__drop_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    name TEXT;
BEGIN
    IF ( table_name is NULL ) THEN
        RETURN;
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 't');
    
    SELECT MADLIB_SCHEMA.__format('SELECT table_name FROM MADLIB_SCHEMA.% 
                                        WHERE table_name IS NOT NULL AND length(trim(table_name, '' '')) > 1',
                                     table_name)
        INTO curstmt;
        
    FOR name IN EXECUTE curstmt LOOP
        EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || table_name || ' CASCADE;';
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create meta table 
 * @param table_name the meta table name  
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    result INT := 0;
BEGIN
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 'f');
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    EXECUTE 'CREATE TABLE MADLIB_SCHEMA.'|| table_name || E'(
        id SERIAL,
        column_name TEXT,
        column_type CHAR,    
        is_cont BOOLEAN,     
        table_name TEXT,
        num_dist_value INT
    ) m4_ifdef(\`GREENPLUM\',\`DISTRIBUTED BY (id)\');';
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert a record to the meta data table
 * @param metatable_name name of meta table
 * @param column_name name of the column
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param is_cont ture if the column is continuous 
 * @param table_name the key-value table name for the specified column
 * @param num_dist_value the number of distinct values for the specified column
 *
 * @note  num_dist_value includes the null value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_metatable
    (
    metatable_name TEXT,
    column_name TEXT,
    column_type CHAR,   
    is_cont BOOLEAN,     
    table_name TEXT,
    num_dist_value INT    
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    metatable_name TEXT,
    column_name TEXT,
    column_type CHAR,   
    is_cont BOOLEAN,     
    table_name TEXT,
    num_dist_value INT         
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert(
        column_type = 'f' OR column_type = 'i' OR column_type = 'c',
        'column type must be ''f'', ''i'' or ''c''');
    
    SELECT MADLIB_SCHEMA.__format('INSERT INTO MADLIB_SCHEMA.% values(default, ''%'', ''%'', ''%'', ''%'', %);',
        ARRAY[
        metatable_name, 
        column_name, 
        column_type, 
        MADLIB_SCHEMA.__to_char(is_cont), 
        table_name, 
        MADLIB_SCHEMA.__to_char(num_dist_value)
        ]) 
        INTO curstmt; 
                
    EXECUTE curstmt;
    
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__distinct_feature_value
    (
    metatable_name TEXT,
    feature_id INT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    metatable_name TEXT,
    feature_id INT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT num_dist_value 
        FROM MADLIB_SCHEMA.% where column_type=''f'' AND id = %;',
        metatable_name,
        MADLIB_SCHEMA.__to_char(feature_id)
        )
    INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_feature
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(*) 
        FROM MADLIB_SCHEMA.% where column_type=''f'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
    class_table_name TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT table_name 
        FROM MADLIB_SCHEMA.% where column_type=''c'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO class_table_name;
    
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(key)
        FROM MADLIB_SCHEMA.%',
        class_table_name
        ) INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the feature index by the specified feature name
 * @param feature_name the feature name
 * @param metatable_name the meta table name
 *
 * @return the feature id 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_index
    (
    feature_name TEXT,
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    feature_name TEXT,
    metatable_name TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result INT := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT id FROM MADLIB_SCHEMA.% where column_name=''%'' AND column_type = ''f'' LIMIT 1;',
            metatable_name,
            feature_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief   Get the feature name by the specified feature index
 * @param feature_index the id of a feature
 * @param metatable_name the meta table name
 *
 * @return the feature name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name
    (
    feature_index INT,
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index INT,
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name FROM MADLIB_SCHEMA.% where id=% AND column_type = ''f'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(feature_index)
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name_list
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_list    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name TEXT;
    result TEXT := 'ARRAY[';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name FROM MADLIB_SCHEMA.' || metatable_name || ' where column_type = ''f'' ORDER BY id;')
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',') || ']';
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the column value by the specified column index and key
 * @param column_index the column id
 * @param key 
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param metatable_name the meta table name
 * 
 * @return the actual value for the specified key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_column_value
    (
    column_index INT,
    key INT,
    column_type CHAR,
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index INT,
    key INT,
    column_type CHAR,
    metatable_name TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curstmt TEXT;
    names TEXT[];
    result TEXT := '';
BEGIN
    IF (column_type = 'c') THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] FROM MADLIB_SCHEMA.% where column_type = ''c'';',
            metatable_name
            )
       INTO curstmt; 
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] FROM MADLIB_SCHEMA.% where id=% AND column_type = ''%'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(column_index),
            column_type
            )
           INTO curstmt;    
    END IF;
                   
    EXECUTE curstmt INTO names;
    
    PERFORM MADLIB_SCHEMA.__assert(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.__assert(names[2] IS NOT NULL, 'No such table name');
    
    IF (key IS NULL ) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% where key is null;',
            names[1],
            names[2]
        )
        INTO curstmt;        
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% where key=%;',
            names[1],
            names[2],
            MADLIB_SCHEMA.__to_char(key)
        )
        INTO curstmt;
    END IF;

    EXECUTE curstmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature value by the specified feature index and key
 * @param feature_index the feature id
 * @param key
 * @param metatable_name the meta table name  
 *
 * @return the value of specified key of the feature whose id specified in feature_index
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_value
    (
    feature_index INT,
    key INT,
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index INT,
    key INT,
    metatable_name TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(feature_index, key, 'f', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class value by the specified key
 * @param key
 * @param metatable_name the meta table name 
 *
 * @return the class value of the key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_value
    (
    key INT,
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    key INT,
    metatable_name TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(0, key, 'c', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Test if the given column_name is a continuous column or not
 * @param column_name name of column
 * @cont_column_names an array contains all the continuous column names
 * 
 * @return true if the specified column is continuous, otherwise return false 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__is_continuous
    (
    column_name TEXT,
    cont_column_names TEXT[]
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    column_name TEXT,
    cont_column_names TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            IF (lower(cont_column_names[i]) = lower(column_name)) THEN
                RETURN 't';
            END IF;
        END LOOP; 
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief encode the tabular table
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param class_column_name class column's name
 * @param cont_column_names an array contains all the continuous feature
 *                        null means no continuous feature
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param verbosity ture if print the debug info  
 *
 * @note  feature names are not specified, use all the table's columns as feature
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    class_column_name TEXT, 
    cont_column_names TEXT[], 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    class_column_name TEXT, 
    cont_column_names TEXT[], 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
declare
    result TEXT := '';
BEGIN
    
    SELECT MADLIB_SCHEMA.__encode_tabular_table
        (
        input_table_name, 
        id_column_name, 
        null,
        class_column_name, 
        cont_column_names, 
        encode_table_name,
        metatable_name,
        h2hmv_routine_id,
        verbosity
        ) 
        INTO result;
        
    RETURN result;    
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief encode tabular table with it's key
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param class_column_name class column's name
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param verbosity ture if print the debug info 
 
 * @note  Feature names are not specified, use all the table's columns as feature
 *        No continuous features
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    class_column_name TEXT, 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ); 
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    class_column_name TEXT, 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__encode_tabular_table
        (
        input_table_name, 
        id_column_name, 
        null,
        class_column_name, 
        null, 
        encode_table_name,
        metatable_name,
        h2hmv_routine_id,
        verbosity
        ) 
        INTO result;
        
    RETURN result;    
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief encode a tabular table
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param feature_names an array contains all the featues
 *                     if it's null, we will get all the columns of the input table
 * @param class_column_name class column's name
 * @param cont_column_names an array contains all the continuous feature
 *                        null means no continuous feature
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param verbosity ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    feature_names TEXT[],
    class_column_name TEXT, 
    cont_column_names TEXT[], 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    feature_names TEXT[],
    class_column_name TEXT, 
    cont_column_names TEXT[], 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    column_name TEXT :='';
    curstmt TEXT := '';
    result_rec RECORD;
    index INT := 1;
    contcolumn_name TEXT;
    contcol_stmt TEXT := '';
    contcol_stmt_quote TEXT := '';
    class_column_lowername TEXT := '';
    id_column_lowername TEXT := '';
    coltable_name TEXT := '';
    drop_col_stmt TEXT := '';
    encode_col_stmt TEXT := '';
    exec_begin TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();

    class_column_lowername = btrim(lower(class_column_name), ' ');
    id_column_lowername = btrim(lower(id_column_name), ' ');
    
    PERFORM MADLIB_SCHEMA.__create_metatable(metatable_name);
    
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            contcolumn_name = lower(cont_column_names[i]);
            contcol_stmt_quote = contcol_stmt_quote || quote_literal(contcolumn_name) || ',';
            contcol_stmt = contcol_stmt || ',' || contcolumn_name;
            
            SELECT MADLIB_SCHEMA.__process_cont_column
                (
                    input_table_name, 
                    id_column_lowername, 
                    contcolumn_name,
                    encode_table_name,
                    metatable_name,
                    't',
                    verbosity
                ) INTO curstmt;
        
            drop_col_stmt = drop_col_stmt || curstmt; 
        END LOOP; 
    END IF;
    
    PERFORM MADLIB_SCHEMA.__create_svec_table
        (
            input_table_name, 
            id_column_lowername, 
            contcol_stmt,
            encode_table_name,
            verbosity
        );

    contcol_stmt_quote = contcol_stmt_quote || '''' || id_column_lowername || '''';
     
    IF (feature_names IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format(
            'select trim(both '' '' from attname) as attname from pg_attribute 
                where attrelid = ''%''::regclass and attnum > 0 and (attname NOT IN (%)) and NOT attisdropped;', 
            input_table_name, contcol_stmt_quote)
            INTO curstmt;   
        
        FOR column_name IN EXECUTE curstmt LOOP
            
            IF (column_name <> class_column_lowername) THEN
                coltable_name = metatable_name || '_' || column_name;
                
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        input_table_name, 
                        id_column_lowername, 
                        column_name,
                        'f',
                        coltable_name ,
                        encode_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    )
                    INTO curstmt;
                    
                drop_col_stmt = drop_col_stmt || curstmt;
                encode_col_stmt = encode_col_stmt || ',' || column_name;
            END IF;
        END LOOP;
    ELSE
        FOR i IN 1..array_upper(feature_names, 1) LOOP
            column_name = feature_names[i];
            IF (NOT MADLIB_SCHEMA.__is_continuous(column_name, cont_column_names)) THEN
                coltable_name = metatable_name || '_' || column_name;    
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        input_table_name, 
                        id_column_lowername, 
                        column_name,
                        'f',
                        coltable_name ,
                        encode_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    )
                    INTO curstmt;
                    
                drop_col_stmt = drop_col_stmt || curstmt;
                encode_col_stmt = encode_col_stmt || ',' || column_name;
            END IF;    
        END LOOP;
    END IF;
    
    -- class column
    coltable_name = metatable_name || '_' || class_column_lowername;
    PERFORM MADLIB_SCHEMA.__process_class_column
        (
            input_table_name, 
            id_column_lowername, 
            class_column_lowername,
            coltable_name,
            encode_table_name,
            metatable_name,
            't',
            verbosity
        ) ;

    encode_col_stmt = contcol_stmt || encode_col_stmt;
    encode_col_stmt = ltrim(encode_col_stmt, ',') ;
    
    SELECT MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_lowername,
            encode_table_name,
            drop_col_stmt, 
            encode_col_stmt, 
            metatable_name,
            't'
        ) 
        INTO curstmt;
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encode_table_name;
END
$$ LANGUAGE PLPGSQL;    

/*
 * @brief Encode a tabular table for classification/score function
 * @param input_table_name the input table name
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param verbosity ture if print the debug info 
 *
 * @note    feature (discrete or continuous) names and keys were retrieved from meta table
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ) CASCADE;
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name TEXT, 
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    id_column_name TEXT;
    temp TEXT := '';
    result_rec RECORD;
    contcol_stmt TEXT := '';
    drop_col_stmt TEXT := '';
    temp_drop_col_stmt TEXT := '';
    encode_col_stmt TEXT := '';
    exec_begin TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();
        
    SELECT MADLIB_SCHEMA.__format('SELECT column_name FROM MADLIB_SCHEMA.% WHERE column_type=''i'';',
        metatable_name)
        INTO curstmt; 
    
    EXECUTE curstmt INTO id_column_name;
    
    SELECT MADLIB_SCHEMA.__format('SELECT column_name FROM MADLIB_SCHEMA.% WHERE is_cont ORDER BY id;',
        metatable_name)
        INTO curstmt; 
        
    FOR temp IN EXECUTE curstmt LOOP
        contcol_stmt = contcol_stmt || ',' || temp;
        
        SELECT MADLIB_SCHEMA.__process_cont_column
            (
                input_table_name, 
                id_column_name, 
                temp,
                encode_table_name,
                metatable_name,
                'f',
                verbosity
            ) INTO temp_drop_col_stmt;
    
        drop_col_stmt = drop_col_stmt || temp_drop_col_stmt; 
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__create_svec_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encode_table_name,
            verbosity
        );
    
    SELECT MADLIB_SCHEMA.__format('SELECT column_name, column_type, is_cont, table_name 
                        FROM MADLIB_SCHEMA.% 
                        WHERE (column_type <> ''i'') AND (NOT is_cont) ORDER BY id',
        metatable_name)
        INTO curstmt; 
                
    FOR result_rec IN EXECUTE curstmt LOOP
        IF (result_rec.column_type = 'f' AND (NOT result_rec.is_cont)) THEN
                SELECT MADLIB_SCHEMA.__process_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        'f',
                        result_rec.table_name,
                        encode_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        'f',
                        verbosity
                    )
                    INTO curstmt;
                    
                drop_col_stmt = drop_col_stmt || curstmt;
                encode_col_stmt = encode_col_stmt || ',' || result_rec.column_name;
        ELSIF (result_rec.column_type = 'c') THEN
                PERFORM MADLIB_SCHEMA.__process_class_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        result_rec.table_name,
                        encode_table_name,
                        metatable_name,
                        'f',
                        verbosity
                    ) ;
        ELSE
            -- nothing need to do for id column
        END IF;
    END LOOP;
    
    encode_col_stmt = contcol_stmt || encode_col_stmt;
    encode_col_stmt = ltrim(encode_col_stmt, ',') ;
    
    SELECT MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            encode_table_name,
            drop_col_stmt, 
            encode_col_stmt, 
            metatable_name,
            'f'
        ) 
        INTO curstmt;
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encode_table_name;
END
$$ LANGUAGE PLPGSQL;
   
   
/*
 * @brief The post process for converting
 * @param id_column_name the name of id column 
 * @param encode_table_name the encoding table name
 * @param drop_col_stmt the drop column statements
 *                    we will copy all the column name to the encoding table
 *                    but it these columns' value is the key, after construct the 
 *                    encoding table, we will drop these auxiliary table
 * @param metatable_name the meta table name
 * @param is_create_metatable true if create the meta table
 *                              for classify/score functionality, which will convert
 *                              the input table, in this case, we needn't create the
 *                              meta table. Just make use of the table                               
 * @return the string contains the drop column statement   
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 */   
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name TEXT,
    encode_table_name TEXT,
    drop_col_stmt TEXT, 
    encode_col_stmt TEXT, 
    metatable_name TEXT,
    is_create_metatable BOOLEAN
    ) CASCADE;
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name TEXT,
    encode_table_name TEXT,
    drop_col_stmt TEXT, 
    encode_col_stmt TEXT, 
    metatable_name TEXT,
    is_create_metatable BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (is_create_metatable) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable(metatable_name, id_column_name, 'i', 'f', '', 0);
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Create the encoding table
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param contcol_stmt a string contains all the continuous feature names 
 *                    with delimiter ','
 * @param encode_table_name the encoding table name
 * @param verbosity ture if print the debug info 
 *
 * @return the encoding table name  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_svec_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    contcol_stmt TEXT,
    encode_table_name TEXT,
    verbosity BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_svec_table
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    contcol_stmt TEXT,
    encode_table_name TEXT,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    rec RECORD;
BEGIN
    IF (verbosity) THEN
        RAISE INFO 'continuous columns:%', contcol_stmt;
    END IF;
    
    -- create result table, and get all the id and continuous columns' value
    EXECUTE 'DROP TABLE IF EXISTS ' || encode_table_name || ' CASCADE;';
    
    -- encode_col_stmt has a comma in the front
    SELECT MADLIB_SCHEMA.__format(
        'CREATE TABLE %(id %) AS SELECT % % FROM % DISTRIBUTED BY(id);', 
        ARRAY[encode_table_name, contcol_stmt, id_column_name, contcol_stmt, input_table_name])
        INTO curstmt;
            
    EXECUTE curstmt;
     
    RETURN  encode_table_name ;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Process the continuous feature
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param column_name name of the column
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return the string contains the drop column statement     
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_cont_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_cont_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    num INT := 0;
BEGIN
    -- insert the continuous features
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT COUNT(DISTINCT %) FROM %',
            column_name, input_table_name)
            INTO curstmt;
        
        EXECUTE curstmt INTO num;
        
        PERFORM MADLIB_SCHEMA.__insert_into_metatable(metatable_name, column_name, 'f', 't', '', num);
    END IF;
    
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % DROP COLUMN % CASCADE;', encode_table_name, column_name) 
        INTO curstmt;
    
    RETURN curstmt;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief   Process the class column
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param column_name name of the column
 * @param coltable_name the table name for the specified column
 *                     this table is the key-value table for this column
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return an empty string      
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_class_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    coltable_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_class_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    coltable_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    column_type CHAR := 'c';
BEGIN
    PERFORM MADLIB_SCHEMA.__process_discrete_column
    (
        input_table_name, 
        id_column_name, 
        column_name,
        column_type,
        coltable_name,
        encode_table_name,
        metatable_name,
        1,
        is_persistent,
        verbosity
    );
    
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format
            ('INSERT INTO MADLIB_SCHEMA.% VALUES(null, null)',
            coltable_name)
        INTO curstmt;
       
        EXECUTE curstmt;
    END IF;
    
    -- rename the class column with "class"
    IF ((column_name IS NOT NULL) AND (column_name <> '') AND (column_name <> 'class')) THEN
        SELECT MADLIB_SCHEMA.__format('ALTER TABLE % RENAME % to class', encode_table_name, column_name) 
            INTO curstmt;
        
        EXECUTE curstmt;
    END IF;
    
    RETURN '';
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief   Process the discrete feature
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param column_name name of the column
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param coltable_name the table name for the specified column
 *                     this table is the key-value table for this column
 * @param encode_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return the string contains the drop column statement    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__process_discrete_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    column_type CHAR,
    coltable_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__process_discrete_column
    (
    input_table_name TEXT, 
    id_column_name TEXT, 
    column_name TEXT,
    column_type CHAR,
    coltable_name TEXT,
    encode_table_name TEXT,
    metatable_name TEXT,
    h2hmv_routine_id INT,
    is_persistent BOOLEAN,
    verbosity BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    index INT := 1;
    name TEXT := '';
    temp TEXT;
BEGIN
    -- For each column, we will create a table for it. 
    -- The table stores the key->value, and distributed by value for parallelism                            
    IF (is_persistent) THEN
        EXECUTE 'DROP TABLE IF EXISTS MADLIB_SCHEMA.' || coltable_name || ';';
                
        -- create table with columns: key, value
        SELECT MADLIB_SCHEMA.__format(
            'CREATE TABLE MADLIB_SCHEMA.% (%, key)  
            AS SELECT DISTINCT %, 1 FROM %   
            DISTRIBUTED BY(%);', 
            ARRAY[
            coltable_name, 
            column_name,
            column_name, 
            input_table_name,
            column_name
            ]) 
            INTO curstmt;
        
        IF (verbosity) THEN    
            RAISE INFO 'Create table: %', curstmt;
        END IF;
        EXECUTE curstmt;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% ORDER BY %',
            column_name,
            coltable_name,
            column_name)
            INTO curstmt;
            
       index = 1;
       FOR name IN EXECUTE (curstmt) LOOP
            IF ((name IS null) OR (name = '?') OR (length(btrim(name, ' ')) = 0)) THEN
                temp = 'null';
                IF (h2hmv_routine_id = 2) THEN
                    temp = MADLIB_SCHEMA.__to_char(index);
                    index = index + 1;
                END IF;
                
                IF (name IS NULL) THEN
                    SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.%  SET key=% WHERE % IS NULL',
                    coltable_name, temp, column_name)
                    INTO curstmt;
                ELSE
                    SELECT MADLIB_SCHEMA.__format(
                        'UPDATE MADLIB_SCHEMA.% SET key = % WHERE %=''%'';',
                        coltable_name,
			             temp,
                        column_name,
                        name)
                        INTO curstmt;
                END IF;
		
		      EXECUTE curstmt;
		      
            ELSE
                SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.% SET key=% WHERE %=''%'';',
                    coltable_name,
                    MADLIB_SCHEMA.__to_char(index),
                    column_name,
                    replace(name, '''', ''''''))
                    INTO curstmt;
                index = index + 1;
            END IF;
            
            EXECUTE curstmt;
        END LOOP;
    END IF;
    

    -- We impose a hard limit, which is 8 million, on the number of distinct classes.
    -- This should be a large enough number for real world applications.
    IF ((column_type = 'c') AND (index > (1024 * 1024 * 8))) THEN
        RAISE EXCEPTION '%', 'The number of distinct class values can''t exceed 8 million!';
    END IF;
    
    -- Add the column to the result table
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % ADD COLUMN % INT', encode_table_name, column_name)
            INTO curstmt;
    EXECUTE curstmt;
    
    -- update result table (value -> key)
    SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=s.key FROM MADLIB_SCHEMA.% s, % p 
                            WHERE (s.% = p.% OR (s.% is NULL AND p.% is NULL)) AND %.id=p.%;',
                      ARRAY[
                      encode_table_name,
                      column_name,
                      coltable_name,
                      input_table_name,
                      column_name,
                      column_name,
                      column_name,
                      column_name,
                      encode_table_name,
                      id_column_name])
             INTO curstmt;
    IF (verbosity) THEN    
        RAISE INFO 'update stmt: %', curstmt;
    END IF;
    
    EXECUTE curstmt;     
    
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable(metatable_name, column_name, column_type, 'f', coltable_name, index - 1);
    END IF;
    
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % DROP COLUMN % CASCADE;', encode_table_name, column_name) 
    INTO curstmt;
    
    RETURN curstmt;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Convert a string with delimiter ',' to an array 
 * @param csv_str a string with delimiter ','
 *
 * @return the splitting string array    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__csvstr_to_array
    (
    csv_str TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__csvstr_to_array 
    (
    csv_str TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret TEXT[];
    str_val TEXT;
    index INTEGER;
BEGIN
    ret = string_to_array(lower(csv_str), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = lower(btrim(ret[index], ' '));
        END LOOP;
    END IF;

    RETURN ret;
END
$$ LANGUAGE PLPGSQL;
          
