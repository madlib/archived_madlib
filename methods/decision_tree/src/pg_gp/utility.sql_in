/*
 * @brief Convert bigint to char
 * @param val Bigint value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BIGINT
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    RETURN val::TEXT;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert float to char
 * @param val float value
 */
 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val FLOAT8
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    RETURN val::TEXT;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert boolean to char
 * @param val boolean value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE 
BEGIN
    IF (val) THEN
        RETURN 't';
    ELSE
        RETURN 'f';
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Format a string with the value in allvalues array
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 *       The number of '%' should be equal with the length of array allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    allvalues   TEXT[]
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    allvalues   TEXT[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt        TEXT := '';
    parts       TEXT[];
    idx         INT := 1;
    curpart     TEXT;
    curvalue    TEXT;
BEGIN
    SELECT regexp_split_to_array(format_str, '%') INTO parts;
    
    LOOP
        curpart = parts[idx];
        curValue = allvalues[idx];
        IF (curpart IS NULL OR curValue IS NULL ) THEN
            EXIT;
        END IF;
        
        stmt = stmt || curpart || curValue;
        idx = idx + 1;
    END LOOP;
    
    IF (curpart IS NOT NULL) THEN
        stmt = stmt || curpart;
    END IF;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Short form to format a string with four parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 * @param value4 The fouth value
    
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT,
    value4      TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT,
    value4      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3, value4]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with three parameters
 * @param value1 The first value
 * @param value2 The second value
 * @param value3 The third value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT, 
    value3      TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2, value3]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with two parameters
 * @param value1 The first value
 * @param value2 The second value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT, 
    value2      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1, value2]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with a parameter
 * @param value1 The first value
 *
 * @note All the char ('%') in format_str will be replaced with allvalues
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str  TEXT, 
    value1      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(format_str, ARRAY[value1]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief   Format a string with the value in allvalues array
 *          All the char ('%') in format_str will be replaced with allvalues
 *          If a element in quotes is t, then the value in allvalues will be quoted.
 *          Such as, allvalues: ['1', '2'], and quotes: ['f', 't']
 *          then allvalues will be change to [''1'', ''2''] 
 *
 * @param format_str the format string
 * @param allvalues the specified elements in format_str
 * @param quotes specify which string in the array should add quote
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__format
    (
    format_str      TEXT, 
    allvalues       TEXT[], 
    quotes          BOOLEAN[]
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    format_str      TEXT, 
    allvalues       TEXT[], 
    quotes          BOOLEAN[]
    ) 
RETURNS TEXT AS $$
DECLARE
    stmt            TEXT := '';
    temp_allvalues  TEXT[];
    idx             INT := 1;
    quote           TEXT;
BEGIN
    LOOP
        quote = quotes[idx];
        IF (quote IS NULL) THEN
            EXIT;
        END IF;
        stmt = allvalues[idx];
        IF (quote) THEN
            SELECT quote_literal( allvalues[idx] ) INTO stmt;
        END IF;
        
        temp_allvalues[idx] = stmt;
        idx = idx + 1;
    END LOOP;
    
    SELECT MADLIB_SCHEMA.__format(format_str, temp_allvalues) INTO stmt;
    
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief assert function
 * @param condition the assert condition
 * @param reason the reason string, which will be display when assert failure
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Test if the specified table under the specified schema exists or not
 * @param schema_name schema name of the table
 * @param table_name the short table name without schema name
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__table_exists
    (
    schema_name  TEXT,
    table_name   TEXT
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    schema_name  TEXT,
    table_name   TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curstmt         TEXT := '';
    result          INT := 0;
    schema_name_c   TEXT := '';
    table_name_c    TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (schema_name IS NOT NULL, 'Schema name must not be null!');
        
    PERFORM MADLIB_SCHEMA.__assert
        (table_name IS NOT NULL, 'Table name must not be null!');
    
    IF (length(btrim(lower(schema_name), ' ')) = 0 OR (schema_name IS NULL)) THEN
        schema_name_c = 'public';
    ELSE
        schema_name_c = schema_name;
    END IF;
    
    table_name_c = btrim(lower(table_name), ' ');
    
    SELECT MADLIB_SCHEMA.__format('SELECT count(c.oid)
        FROM pg_catalog.pg_class c
        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE btrim(c.relname, '' '') = ''%''
        AND btrim(n.nspname, '' '') = ''%'';',
        table_name_c,
        schema_name_c
        )
        INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result >= 1;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief assert if the specified table under the specified schema exists or not
 * @param schema_name schema name of the table
 * @param table_name the short table name without schema name
 * @param existence ture if assert table exists, otherwise false
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__assert
    (
    schema_name     TEXT,
    table_name      TEXT,
    existence       BOOLEAN
    );
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    schema_name     TEXT,
    table_name      TEXT,
    existence       BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    err_msg     TEXT;
BEGIN
    IF (existence) THEN
        err_msg = 'assertion failure. Table: ''' || table_name || ''' does not exist';
    ELSE
        err_msg = 'assertion failure. Table: ''' || table_name || ''' already exists';
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert
        (
        MADLIB_SCHEMA.__table_exists(schema_name, table_name) = existence, 
        err_msg
        );
END
$$ LANGUAGE PLPGSQL;

/*
 * This is a global table to store information for various tree training.
 */
DROP TABLE IF EXISTS MADLIB_SCHEMA.training_info;
CREATE TABLE MADLIB_SCHEMA.training_info
    (
    tree_table_name TEXT        NOT NULL,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT,
    PRIMARY KEY (tree_table_name)
    ) m4_ifdef(`GREENPLUM',`DISTRIBUTED BY (tree_table_name)');

GRANT ALL PRIVILEGES ON MADLIB_SCHEMA.training_info TO PUBLIC;
/*
 * @brief get the meta table name by the tree table name
 * @param tree_table tree table name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_metatable_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    metatable_name TEXT := '';
BEGIN

    PERFORM MADLIB_SCHEMA.__assert
            (
                MADLIB_SCHEMA.__get_schema_name(tree_table),
                MADLIB_SCHEMA.__strip_schema_name(tree_table),
                't'
            );     
    
    PERFORM MADLIB_SCHEMA.__assert
            (
                'MADLIB_SCHEMA',
                'training_info',
                't'
            ); 
            
    SELECT training_metatable_name 
    FROM MADLIB_SCHEMA.training_info 
    WHERE tree_table_name = tree_table 
    INTO metatable_name;
    
    RETURN metatable_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the class table name by the tree table name
 * @param tree_table tree table name
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_classtable_name
    (
    metatable_name TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_classtable_name
    (
    metatable_name TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    classtable_name TEXT;
BEGIN

    PERFORM MADLIB_SCHEMA.__assert
            (
                'MADLIB_SCHEMA',
                metatable_name,
                't'
            ); 
            
    EXECUTE ' SELECT table_name 
              FROM MADLIB_SCHEMA.' || metatable_name ||
            ' WHERE column_type = ''c'';'  
    INTO classtable_name;
    
    RETURN classtable_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the encoding table name by tree table name
 * @param tree_table tree table name
 * 
 * @return the encoding table name
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_encode_table_name
    (
    tree_table TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    encoded_table_name TEXT := '';
BEGIN
    SELECT training_encoded_table_name 
    FROM MADLIB_SCHEMA.training_info
    WHERE tree_table_name = tree_table 
    INTO encoded_table_name;
    
    RETURN encoded_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the unknown values processing routine id 
 * @param tree_table tree table name         
 *  
 * @note currently, we only support 'explicit'
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
DECLARE
    name TEXT;
BEGIN
    
    PERFORM MADLIB_SCHEMA.__assert
    (
        'MADLIB_SCHEMA',
        'training_info',
        't'
    );
        
    SELECT how2handle_missing_value 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  tree_table_name = tree_table 
    INTO   name;
        
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSIF (name = 'explicit') THEN
        RETURN 2;
    ELSE
        RAISE EXCEPTION '__get_routine_id: %', name; 
    END IF;
    
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the name of column containing feature
 * @param tree_table tree table name         
 *  
 * @return the name of column containing feature
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    feature_name TEXT;
BEGIN
    SELECT feature_col_names 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  tree_table_name = tree_table 
    INTO   feature_name;
        
    RETURN feature_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief get the name of column containing class
 * @param tree_table tree table name         
 *  
 * @return the name of column containing class
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name
    (
    tree_table TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    class_name TEXT;
BEGIN
    SELECT class_col_name 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  tree_table_name = tree_table 
    INTO   class_name;
        
    RETURN class_name;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief Remove the trained tree from training info table 
 * @param tree_table tree table name 
 *  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    );            
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__delete_traininginfo
    (
    tree_table TEXT 
    ) 
RETURNS void AS $$
BEGIN
    DELETE FROM MADLIB_SCHEMA.training_info WHERE tree_table_name = tree_table;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief insert the trained tree into training info table 
 * @param result_tree_table_name tree table name
 * @param training_table_name training table name
 * @param training_metatable_name name of training data table
 * @param training_encoded_table_name name of encoding table 
 * @param validation_table_name validation table name
 * @param how2handle_missing_value the routine to process unknown values
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name      TEXT,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT  
    );
               
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_traininginfo
    (
    result_tree_table_name      TEXT,
    training_table_name         TEXT,
    training_metatable_name     TEXT,
    training_encoded_table_name TEXT,
    validation_table_name       TEXT,
    how2handle_missing_value    TEXT,
    split_criterion             TEXT  
    )
RETURNS void AS $$
BEGIN
    INSERT INTO MADLIB_SCHEMA.training_info VALUES
                        (
                        result_tree_table_name,
                        training_table_name,
                        training_metatable_name,
                        training_encoded_table_name,
                        validation_table_name,
                        how2handle_missing_value,
                        split_criterion
                        );
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief  set the encoding table name and training data table name 
 *          in the training info table
 * @param result_tree_table_name tree table name
 * @param metatable_name name of training data table
 * @param encoded_table_name name of encoded table 
 *  
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name  TEXT,
    metatable_name          TEXT,
    encoded_table_name      TEXT
    );        
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__set_encode_and_metatable_name
    (
    result_tree_table_name  TEXT,
    metatable_name          TEXT,
    encoded_table_name      TEXT
    ) 
RETURNS void AS $$
BEGIN
    UPDATE MADLIB_SCHEMA.training_info 
    SET training_metatable_name = metatable_name,
        training_encoded_table_name = encoded_table_name 
    WHERE tree_table_name = result_tree_table_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief  Strip the schema name from the full name 
 * @param full_name the full name of table (with schema name)
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
BEGIN
    str_val = trim(both ' ' FROM split_part(full_name, '.', 2));

    IF( str_val is null or str_val = '' ) THEN
        str_val = trim(both ' ' FROM full_name);
    END IF;
    RETURN str_val;
end
$$ LANGUAGE PLPGSQL;

/*
 * @brief get the schema name from a full database object name
 * @param full_name the fullname of a database object
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) ;          
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
    ret_val TEXT;
BEGIN
    str_val = btrim(split_part(full_name, '.', 2), ' ');

    IF( str_val is null or str_val = '' ) THEN
        ret_val = 'public';
    ELSE
        ret_val = btrim(split_part(full_name, '.', 1), ' ');
    END IF;
    RETURN ret_val;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Drop the meta table,  
 *        Drop all the tables whose names are in 'ttable_name column
 * @param table_name the meta table name
 *
 * @note the name of parameter will be add the MADLIB_SCHEMA automatically
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__drop_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    name    TEXT;
BEGIN
    IF ( table_name is NULL ) THEN
        RETURN;
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 't');
    
    SELECT MADLIB_SCHEMA.__format
            (
            'SELECT table_name FROM MADLIB_SCHEMA.% 
            WHERE table_name IS NOT NULL AND length(trim(table_name, '' '')) > 1',
            table_name
            ) 
    INTO curstmt;
        
    FOR name IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', name, 't');
        EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE MADLIB_SCHEMA.' || table_name || ' CASCADE;';
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create meta table 
 * @param table_name the meta table name  
 *
 * @note 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_metatable
    (
    table_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    table_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(table_name)) <= 63, 
            'The maximum length of ' || table_name || ' is 63'
        );
        
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert('MADLIB_SCHEMA', table_name, 'f');
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    EXECUTE 'CREATE TABLE MADLIB_SCHEMA.'|| table_name || E'(
        id SERIAL,
        column_name TEXT,
        column_type CHAR,    
        is_cont BOOLEAN,     
        table_name TEXT,
        num_dist_value INT
    ) m4_ifdef(`GREENPLUM',`DISTRIBUTED BY (id)');';
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert a record to the meta data table
 * @param metatable_name name of meta table
 * @param column_name name of the column
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param is_cont ture if the column is continuous 
 * @param table_name the key-value table name for the specified column
 * @param num_dist_value the number of distinct values for the specified column
 *
 * @note  num_dist_value includes the null value
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__insert_into_metatable
    (
    metatable_name      TEXT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT    
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    metatable_name      TEXT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT         
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert(
        column_type = 'f' OR column_type = 'i' OR column_type = 'c',
        'column type must be ''f'', ''i'' or ''c''');
    
    SELECT MADLIB_SCHEMA.__format(
        'INSERT INTO MADLIB_SCHEMA.% VALUES(default, ''%'', ''%'', ''%'', ''%'', %);',
        ARRAY[
        metatable_name, 
        column_name, 
        column_type, 
        MADLIB_SCHEMA.__to_char(is_cont), 
        table_name, 
        MADLIB_SCHEMA.__to_char(num_dist_value)
        ]) 
        INTO curstmt; 
                
    EXECUTE curstmt;
    
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__distinct_feature_value
    (
    metatable_name  TEXT,
    feature_id      INT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    metatable_name  TEXT,
    feature_id      INT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt     TEXT := '';
    result      INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT num_dist_value 
        FROM MADLIB_SCHEMA.% WHERE column_type=''f'' AND id = %;',
        metatable_name,
        MADLIB_SCHEMA.__to_char(feature_id)
        )
    INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_feature
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(*) 
        FROM MADLIB_SCHEMA.% WHERE column_type=''f'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    metatable_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt             TEXT := '';
    result              INT4 := 0;
    class_table_name    TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT table_name 
        FROM MADLIB_SCHEMA.% WHERE column_type=''c'';',
        metatable_name
        )
        INTO curstmt; 
                
    EXECUTE curstmt INTO class_table_name;
    
    SELECT MADLIB_SCHEMA.__format
        (
        'SELECT COUNT(key)
        FROM MADLIB_SCHEMA.%',
        class_table_name
        ) INTO curstmt;
    
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the feature index by the specified feature name
 * @param feature_name the feature name
 * @param metatable_name the meta table name
 *
 * @return the feature id 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_index
    (
    feature_name    TEXT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    feature_name    TEXT,
    metatable_name  TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT  id 
             FROM    MADLIB_SCHEMA.% 
             WHERE   column_name=''%'' AND column_type = ''f'' 
             LIMIT   1;',
            metatable_name,
            feature_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature name by the specified feature index
 * @param feature_index the id of a feature
 * @param metatable_name the meta table name
 *
 * @return the feature name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name
    (
    feature_index   INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index   INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name 
             FROM   MADLIB_SCHEMA.% 
             WHERE  id = % AND column_type = ''f'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(feature_index)
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name_list
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_list    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := 'ARRAY[';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   MADLIB_SCHEMA.' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',') || ']';
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_name_in_selectstmt
    (
    metatable_name TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name_in_selectstmt    
    (
    metatable_name TEXT
    )
RETURNS TEXT AS $$
DECLARE
    name    TEXT;
    result  TEXT := '';
BEGIN
    FOR name IN EXECUTE 
        ('SELECT column_name 
          FROM   MADLIB_SCHEMA.' || metatable_name || ' ' ||
         'WHERE  column_type = ''f'' ORDER BY id;'
        )
        LOOP
        result = result || name || ',';
    END LOOP;
    
    result = rtrim(result, ',');
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the column value by the specified column index and key
 * @param column_index the column id
 * @param key the key of returned value
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param metatable_name the meta table name
 * 
 * @return the actual value for the specified key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_column_value
    (
    column_index    INT,
    key             INT,
    column_type     CHAR,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index    INT,
    key             INT,
    column_type     CHAR,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curstmt     TEXT;
    names       TEXT[];
    result      TEXT := '';
BEGIN
    IF (column_type = 'c') THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] 
             FROM   MADLIB_SCHEMA.% 
             WHERE  column_type = ''c'';',
            metatable_name
            )
       INTO curstmt; 
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT ARRAY[column_name, table_name] 
             FROM   MADLIB_SCHEMA.% 
             WHERE  id = % AND column_type = ''%'';',
            metatable_name,
            MADLIB_SCHEMA.__to_char(column_index),
            column_type
            )
           INTO curstmt;    
    END IF;
                   
    EXECUTE curstmt INTO names;
    
    PERFORM MADLIB_SCHEMA.__assert(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.__assert(names[2] IS NOT NULL, 'No such table name');
    
    IF (key IS NULL ) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% WHERE key is null;',
            names[1],
            names[2]
        )
        INTO curstmt;        
    ELSE
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% WHERE key=%;',
            names[1],
            names[2],
            MADLIB_SCHEMA.__to_char(key)
        )
        INTO curstmt;
    END IF;

    EXECUTE curstmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature value by the specified feature index and key
 * @param feature_index the feature id
 * @param key the key of returned value
 * @param metatable_name the meta table name  
 *
 * @return the value of specified key of the feature whose id specified in feature_index
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_feature_value
    (
    feature_index   INT,
    key             INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index   INT,
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(feature_index, key, 'f', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class name
 * @param metatable_name the meta table name
 *
 * @return the class name 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_column_name
    (
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name    
    (
    metatable_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            'MADLIB_SCHEMA',
            metatable_name,
            't'
        );
        
    SELECT MADLIB_SCHEMA.__format(
            'SELECT column_name 
             FROM   MADLIB_SCHEMA.% 
             WHERE  column_type = ''c'' LIMIT 1',
            metatable_name
        )
        INTO curstmt;
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Get the class value by the specified key
 * @param key key the key of returned value
 * @param metatable_name the meta table name 
 *
 * @return the class value of the key 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__get_class_value
    (
    key             INT,
    metatable_name  TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    key             INT,
    metatable_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__get_column_value(0, key, 'c', metatable_name)
        INTO result;
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Test if the given column_name is a continuous column or not
 * @param column_name name of column
 * @cont_column_names an array contains all the continuous column names
 * 
 * @return true if the specified column is continuous, otherwise return false 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__is_continuous
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            IF (cont_column_names[i] = column_name) THEN
                RETURN 't';
            END IF;
        END LOOP; 
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief encode a tabular table
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param feature_names         an array contains all the feature. If it's null, 
                                we will get all the columns of the input table
 * @param class_column_name     class column's name
 * @param cont_column_names     an array contains all the continuous feature
 *                              null means no continuous feature
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param h2hmv_routine_id      the id of the routine which specifies 
                                how to handle missing value(h2hmv)
 * @param verbosity             ture if print the debug info 
 *
 * @note The name convension of the table for a column is: metatable_name || '_' || col_index 
 *       col_index is start from 1, and end at 9999 
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    feature_names       TEXT[],
    class_column_name   TEXT, 
    cont_column_names   TEXT[], 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    feature_names       TEXT[],
    class_column_name   TEXT, 
    cont_column_names   TEXT[], 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    column_name         TEXT :='';
    curstmt             TEXT := '';
    result_rec          RECORD;
    col_index           INT := 1;
    contcol_stmt        TEXT := '';
    contcol_stmt_quote  TEXT := '';
    coltable_name       TEXT := rtrim(metatable_name, 'di');
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();

    PERFORM MADLIB_SCHEMA.__create_metatable(metatable_name);
    
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            contcol_stmt_quote = contcol_stmt_quote || quote_literal(cont_column_names[i]) || ',';
            contcol_stmt = contcol_stmt || ',' || cont_column_names[i];
        END LOOP; 
    END IF;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    contcol_stmt_quote = contcol_stmt_quote || '''' || id_column_name || '''';

    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            PERFORM MADLIB_SCHEMA.__encode_cont_column
                (
                    input_table_name, 
                    id_column_name, 
                    cont_column_names[i],
                    coltable_name || col_index,
                    encoded_table_name,
                    metatable_name,
                    h2hmv_routine_id,
                    't',
                    verbosity
                );
            
            col_index = col_index + 1;
        END LOOP; 
    END IF;
         
    IF (feature_names IS NULL) THEN
        SELECT MADLIB_SCHEMA.__format(
            'SELECT btrim(attname, '' '') as attname 
             FROM   pg_attribute 
             WHERE  attrelid = ''%''::regclass and attnum > 0 AND 
                    (attname NOT IN (%)) AND 
                    NOT attisdropped;', 
            input_table_name, contcol_stmt_quote)
            INTO curstmt;   
        
        FOR column_name IN EXECUTE curstmt LOOP
            
            IF (column_name <> class_column_name) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                
                col_index = col_index + 1;
            END IF;
        END LOOP;
    ELSE
        FOR i IN 1..array_upper(feature_names, 1) LOOP
            column_name = feature_names[i];
            IF (NOT MADLIB_SCHEMA.__is_continuous(column_name, cont_column_names)) THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        column_name,
                        'f',
                        coltable_name || col_index ,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        't',
                        verbosity
                    );
                    
                col_index = col_index + 1;
            END IF;    
        END LOOP;
    END IF;
    
    -- class column
    PERFORM MADLIB_SCHEMA.__encode_class_column
        (
            input_table_name, 
            id_column_name, 
            class_column_name,
            coltable_name || col_index,
            encoded_table_name,
            metatable_name,
            't',
            verbosity
        ) ;

    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            't'
        );
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;    

/*
 * @brief Encode a tabular table for classification/scoring
 * @param input_table_name the input table name
 * @param encoded_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param h2hmv_routine_id the id of the routine which specifies 
                            how to handle missing value(h2hmv) 
 * @param verbosity ture if print the debug info 
 *
 * @note  feature (discrete or continuous) names and keys were retrieved from meta table
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_table_name    TEXT, 
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt             TEXT;
    id_column_name      TEXT;
    temp                TEXT := '';
    result_rec          RECORD;
    contcol_stmt        TEXT := '';
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();
        
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name FROM MADLIB_SCHEMA.% WHERE column_type=''i'';',
        metatable_name)
        INTO curstmt; 
    
    EXECUTE curstmt INTO id_column_name;
    
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name, table_name FROM MADLIB_SCHEMA.% WHERE is_cont ORDER BY id;',
        metatable_name)
        INTO curstmt; 
        
    FOR result_rec IN EXECUTE curstmt LOOP
        contcol_stmt = contcol_stmt || ',' || result_rec.column_name;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__create_encoded_table
        (
            input_table_name, 
            id_column_name, 
            contcol_stmt,
            encoded_table_name,
            verbosity
        );

    FOR result_rec IN EXECUTE curstmt LOOP
        PERFORM MADLIB_SCHEMA.__encode_cont_column
            (
                input_table_name, 
                id_column_name, 
                result_rec.column_name,
                result_rec.table_name,
                encoded_table_name,
                metatable_name,
                h2hmv_routine_id,
                'f',
                verbosity
            );
    END LOOP;
        
    SELECT MADLIB_SCHEMA.__format
        ('SELECT column_name, column_type, table_name 
          FROM   MADLIB_SCHEMA.% 
          WHERE  (column_type <> ''i'') AND (NOT is_cont) ORDER BY id',
        metatable_name)
        INTO curstmt; 
                
    FOR result_rec IN EXECUTE curstmt LOOP
        IF (result_rec.column_type = 'f') THEN
                PERFORM MADLIB_SCHEMA.__encode_discrete_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        'f',
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        h2hmv_routine_id,
                        'f',
                        verbosity
                    );
        ELSIF (result_rec.column_type = 'c') THEN
                PERFORM MADLIB_SCHEMA.__encode_class_column
                    (
                        input_table_name, 
                        id_column_name, 
                        result_rec.column_name,
                        result_rec.table_name,
                        encoded_table_name,
                        metatable_name,
                        'f',
                        verbosity
                    );
        ELSE
            -- nothing need to do for id column
        END IF;
    END LOOP;
    
    PERFORM MADLIB_SCHEMA.__post_encode_tabular_table
        (
            id_column_name,
            metatable_name,
            'f'
        );
    
    IF (verbosity) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;
   
   
/*
 * @brief The post process for encoding
 *
 * @param id_column_name the name of id column 
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 *
 * @return the string contains the drop column statement   
 *
 */   
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name      TEXT,
    metatable_name      TEXT,
    is_persistent       BOOLEAN
    ) CASCADE;
    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__post_encode_tabular_table
    (
    id_column_name      TEXT,
    metatable_name      TEXT,
    is_persistent       BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
BEGIN
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, id_column_name, 'i', 'f', '', 0);
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Create the encoding table
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param contcol_stmt a string contains all the continuous feature names 
 *                    with delimiter ','
 * @param encoded_table_name the encoding table name
 * @param verbosity ture if print the debug info 
 *
 * @return the encoding table name  
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_encoded_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    contcol_stmt        TEXT,
    encoded_table_name  TEXT,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_encoded_table
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    contcol_stmt        TEXT,
    encoded_table_name  TEXT,
    verbosity           BOOLEAN
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT := '';
    rec     RECORD;
BEGIN

    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(encoded_table_name)) <= 63, 
            'The maximum length of ' || encoded_table_name || ' is 63'
        );
        
        
    IF (verbosity) THEN
        RAISE INFO 'continuous columns:%', contcol_stmt;
    END IF;
    
    -- create result table, and get all the id and continuous columns' value
    EXECUTE 'DROP TABLE IF EXISTS ' || encoded_table_name || ' CASCADE;';
    
    SELECT MADLIB_SCHEMA.__format(
        'CREATE TABLE %(id %) AS SELECT % % FROM % m4_ifdef(`GREENPLUM',`DISTRIBUTED BY(id)');', 
        ARRAY[
            encoded_table_name, 
            contcol_stmt, 
            id_column_name, 
            contcol_stmt, 
            input_table_name
            ])
        INTO curstmt;
            
    EXECUTE curstmt;
     
    RETURN  encoded_table_name ;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the continuous feature
 * @param input_table_name      the input table name
 * @param id_column_name        the name of id column 
 * @param column_name           name of the column
 * @param coltable_name         the table name for the specified column
 *                              this table is used to store the minimal value of this column
 * @param encoded_table_name    the encoding table name
 * @param metatable_name        the meta table name
 * @param h2hmv_routine_id      the id of the routine which specifies 
                                how to handle missing value(h2hmv)
 * @param is_persistent         ture if write the column info into meta table
 * @param verbosity             ture if print the debug info 
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_cont_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    h2hmv_routine_id        INT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_cont_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    h2hmv_routine_id        INT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt         TEXT := '';
    num             INT := 0;
    min_val         FLOAT8;
    coltable_name2  TEXT := coltable_name;
BEGIN
    -- insert the continuous features
    IF (is_persistent) THEN
        IF (h2hmv_routine_id = 2) THEN
            SELECT MADLIB_SCHEMA.__format(
                'SELECT coalesce(min(%), 1) - 1 FROM %', 
                column_name,
                input_table_name) 
                INTO curstmt;
                
            EXECUTE curstmt INTO min_val;
    
            SELECT MADLIB_SCHEMA.__format(
                'CREATE TABLE MADLIB_SCHEMA.%(key) AS SELECT % m4_ifdef(`GREENPLUM',`DISTRIBUTED BY (key)')', 
                coltable_name2,
                MADLIB_SCHEMA.__to_char(min_val)) 
                INTO curstmt;
                
            EXECUTE curstmt;
                    
            SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=% WHERE % is null;',
                          encoded_table_name,
                          column_name,
                          MADLIB_SCHEMA.__to_char(min_val),
                          column_name)
                 INTO curstmt;
                 
            EXECUTE curstmt;
        ELSE
            coltable_name2 = '';
        END IF;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT COUNT(DISTINCT %) FROM %',
            column_name, input_table_name)
            INTO curstmt;
        
        EXECUTE curstmt INTO num;
        
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, 'f', 't', coltable_name2, num);
    ELSE
         IF (h2hmv_routine_id = 2) THEN
             SELECT MADLIB_SCHEMA.__format(
                'SELECT key FROM MADLIB_SCHEMA.% LIMIT 1', 
                coltable_name2) 
                INTO curstmt;
                
            EXECUTE curstmt INTO min_val;
            
            SELECT MADLIB_SCHEMA.__format('UPDATE % SET %=% WHERE % is null',
                          encoded_table_name,
                          column_name,
                          MADLIB_SCHEMA.__to_char(min_val),
                          column_name)
                 INTO curstmt;
                 
            EXECUTE curstmt;
        END IF;
        
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the class column
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param column_name name of the column
 * @param coltable_name the table name for the specified column
 *                     this table is the key-value table for this column
 * @param encoded_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return an empty string      
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_class_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_class_column
    (
    input_table_name        TEXT, 
    id_column_name          TEXT, 
    column_name             TEXT,
    coltable_name           TEXT,
    encoded_table_name      TEXT,
    metatable_name          TEXT,
    is_persistent           BOOLEAN,
    verbosity               BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt     TEXT := '';
    column_type CHAR := 'c';
BEGIN
    PERFORM MADLIB_SCHEMA.__encode_discrete_column
    (
        input_table_name, 
        id_column_name, 
        column_name,
        column_type,
        coltable_name,
        encoded_table_name,
        metatable_name,
        1,
        is_persistent,
        verbosity
    );
    
    IF (is_persistent) THEN
        SELECT MADLIB_SCHEMA.__format
            ('INSERT INTO MADLIB_SCHEMA.% VALUES(null, null)',
            coltable_name)
        INTO curstmt;
       
        EXECUTE curstmt;
    END IF;
    
    -- rename the class column with "class"
    IF ((column_name IS NOT NULL) AND (column_name <> '') AND (column_name <> 'class')) THEN
        SELECT MADLIB_SCHEMA.__format
            ('ALTER TABLE % RENAME % to class', encoded_table_name, column_name) 
            INTO curstmt;
        
        EXECUTE curstmt;
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Encode the discrete feature
 * @param input_table_name the input table name
 * @param id_column_name the name of id column 
 * @param column_name name of the column
 * @param column_type the type of column
 *        'i' means id, 'c' means class, 'f' means feature
 * @param coltable_name the table name for the specified column
 *                     this table is the key-value table for this column
 * @param encoded_table_name the encoding table name
 * @param metatable_name the meta table name
 * @param h2hmv_routine_id the id of the routine which specifies how to handle missing value(h2hmv) 
 * @param is_persistent ture if write the column info into meta table
 * @param verbosity ture if print the debug info 
 *
 * @return the string contains the drop column statement    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__encode_discrete_column
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    column_type         CHAR,
    coltable_name       TEXT,
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    is_persistent       BOOLEAN,
    verbosity           BOOLEAN
    ) CASCADE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_discrete_column
    (
    input_table_name    TEXT, 
    id_column_name      TEXT, 
    column_name         TEXT,
    column_type         CHAR,
    coltable_name       TEXT,
    encoded_table_name  TEXT,
    metatable_name      TEXT,
    h2hmv_routine_id    INT,
    is_persistent       BOOLEAN,
    verbosity           BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
    index   INT := 1;
    name    TEXT := '';
    temp    TEXT;
BEGIN
    -- For each column, we will create a table for it. 
    -- The table stores the key->value, and distributed by value for parallelism                            
    IF (is_persistent) THEN
        EXECUTE 'DROP TABLE IF EXISTS MADLIB_SCHEMA.' || coltable_name || ';';
                
        -- create table with columns: key, value
        SELECT MADLIB_SCHEMA.__format(
            'CREATE TABLE MADLIB_SCHEMA.% (%, key)  
            AS SELECT DISTINCT %, 1 FROM %   
            m4_ifdef(`GREENPLUM',`DISTRIBUTED BY(%)');', 
            ARRAY[
            coltable_name, 
            column_name,
            column_name, 
            input_table_name
            m4_ifdef(`GREENPLUM',`, column_name')
            ]) 
            INTO curstmt;
        
        IF (verbosity) THEN    
            RAISE INFO 'Create table: %', curstmt;
        END IF;
        EXECUTE curstmt;
        
        SELECT MADLIB_SCHEMA.__format(
            'SELECT % FROM MADLIB_SCHEMA.% ORDER BY %',
            column_name,
            coltable_name,
            column_name)
            INTO curstmt;
            
       index = 1;
       FOR name IN EXECUTE (curstmt) LOOP
            IF ((name IS null) OR (name = '?') OR (length(btrim(name, ' ')) = 0)) THEN
                temp = 'null';
                IF (h2hmv_routine_id = 2) THEN
                    temp = MADLIB_SCHEMA.__to_char(index);
                    index = index + 1;
                END IF;
                
                IF (name IS NULL) THEN
                    SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.%  SET key=% WHERE % IS NULL',
                    coltable_name, temp, column_name)
                    INTO curstmt;
                ELSE
                    SELECT MADLIB_SCHEMA.__format(
                        'UPDATE MADLIB_SCHEMA.% SET key = % WHERE %=''%'';',
                        coltable_name,
			             temp,
                        column_name,
                        name)
                        INTO curstmt;
                END IF;
		
		      EXECUTE curstmt;
		      
            ELSE
                SELECT MADLIB_SCHEMA.__format(
                    'UPDATE MADLIB_SCHEMA.% SET key=% WHERE %=''%'';',
                    coltable_name,
                    MADLIB_SCHEMA.__to_char(index),
                    column_name,
                    replace(name, '''', ''''''))
                    INTO curstmt;
                index = index + 1;
            END IF;
            
            EXECUTE curstmt;
        END LOOP;
    END IF;
    

    -- We impose a hard limit, which is 8 million, on the number of distinct classes.
    -- This should be a large enough number for real world applications.
    IF ((column_type = 'c') AND (index > 8000000)) THEN
        RAISE EXCEPTION '%', 'The number of distinct class values can''t exceed 8,000,000!';
    END IF;
    
    -- Add the column to the result table
    SELECT MADLIB_SCHEMA.__format('ALTER TABLE % ADD COLUMN % INT', encoded_table_name, column_name)
            INTO curstmt;
    EXECUTE curstmt;
    
    -- update result table (value -> key)
    SELECT MADLIB_SCHEMA.__format
                    ('UPDATE % SET %=s.key 
                      FROM MADLIB_SCHEMA.% s, % p 
                      WHERE (s.% = p.% OR (s.% is NULL AND p.% is NULL)) AND %.id=p.%;',
                      ARRAY[
                      encoded_table_name,
                      column_name,
                      coltable_name,
                      input_table_name,
                      column_name,
                      column_name,
                      column_name,
                      column_name,
                      encoded_table_name,
                      id_column_name])
             INTO curstmt;
    IF (verbosity) THEN    
        RAISE INFO 'update stmt: %', curstmt;
    END IF;
    
    EXECUTE curstmt;     
    
    IF (is_persistent) THEN
        PERFORM MADLIB_SCHEMA.__insert_into_metatable
            (metatable_name, column_name, column_type, 'f', coltable_name, index - 1);
    END IF;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief Convert a string with delimiter ',' to an array 
 * @param csv_str a string with delimiter ','
 *
 * @return the splitting string array    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__csvstr_to_array
    (
    csv_str TEXT
    );

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__csvstr_to_array 
    (
    csv_str TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret     TEXT[];
    str_val TEXT;
    index   INTEGER;
BEGIN
    ret = string_to_array(lower(csv_str), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = lower(btrim(ret[index], ' '));
        END LOOP;
    END IF;

    RETURN ret;
END
$$ LANGUAGE PLPGSQL;

/*
 * @brief  judge whether the current database support ordered aggregate
 *
 * @return 't'- support, 'f'- no support    
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__ordered_aggregate_support
    (
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ordered_aggregate_support 
    (
    )
RETURNS BOOLEAN AS $$
DECLARE
    support_status  INT;     
BEGIN
    support_status = m4_ifdef(`POSTGRES_PRE_90',`0',
        `m4_ifdef(`GREENPLUM_PRE_41',`0',`1')');
    RETURN support_status<>0;
END
$$ LANGUAGE PLPGSQL;
