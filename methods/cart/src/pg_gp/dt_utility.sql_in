/* ----------------------------------------------------------------------- *//** 
 *
 * @file dt_utility.sql_in
 *
 * @brief Utility functions widely used in C4.5 and random forest.
 * @date April 5, 2012
 *
 *//* ----------------------------------------------------------------------- */


/*
 * @brief Cast any value to text.
 *
 * @param val	A value with any specific type.
 *
 * @return The text format string for the value.
 *
 * @note Greenplum doesn't support boolean to text casting.
 *
 */
DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__to_char
    (
    val anyelement
    );
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__to_char
    (
    val anyelement
    )
RETURNS TEXT AS $$
DECLARE
    is_bool BOOLEAN;
BEGIN
    IF (val is NULL) THEN
        return 'null'::text;
    END IF;
    SELECT pg_typeof(val) = 'boolean'::regtype INTO is_bool;
    IF (is_bool) THEN
         IF (val::boolean) THEN
            RETURN 'true';
         ELSE
            RETURN 'false';
         END IF;
    END IF;
    
    RETURN val::TEXT;

END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Cast regclass to text. we will not create a cast, 
 *        since it may override the existing cast. 
 *        Although there is no cast for regclass to text,
 *        PL/PGSQL can coerce it to text automatically.
 *        Another implementation can use sql function:
 *        select textin(regclassout('pg_class'::regclass));
 *        
 * @param rc	The regclass of the table.
 *
 * @return The text representation for the regclass.
 *
 */
CREATE or replace FUNCTION MADLIB_SCHEMA.__regclass_to_text
    (
    rc regclass
    ) 
RETURNS TEXT                          
AS $$  
BEGIN                
   RETURN rc;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Format a string with the value in args array.
 *
 * @param fmt	The format string.
 * @param args	The specified elements in format string.
 *
 * @return The formated string.
 *
 * @note Each '%' in fmt will be replaced with the corresponding value of args.
 *       The number of '%'s should equal to the length of array args.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt     TEXT, 
    args    TEXT[]
    ) 
RETURNS TEXT
AS 'MODULE_PATHNAME', 'dt_text_format'
LANGUAGE C IMMUTABLE;


/*
 * @brief Short form to format a string with four parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 * @param arg3	The third argument.
 * @param arg4	The fouth argument.
 *   
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt       TEXT, 
    arg1      TEXT, 
    arg2      TEXT, 
    arg3      TEXT,
    arg4      TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2, arg3, arg4]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with three parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 * @param arg3	The third argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT, 
    arg2        TEXT, 
    arg3        TEXT
)
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2, arg3]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with two parameters.
 *
 * @param arg1	The first argument.
 * @param arg2	The second argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT, 
    arg2        TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1, arg2]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Short form to format a string with a parameter.
 *
 * @param arg1	The first argument.
 *
 * @return The formated string.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__format
    (
    fmt         TEXT, 
    arg1        TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt TEXT := '';
BEGIN
    SELECT MADLIB_SCHEMA.__format(fmt, ARRAY[arg1]) INTO stmt;
    RETURN stmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Raise exception if the condition is false.
 *
 * @param condition		The assert condition.
 * @param reason		The reason string displayed when assert failure.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert
    (
    condition   BOOLEAN,
    reason      TEXT
    ) 
RETURNS void AS $$
BEGIN
    IF (NOT condition) THEN
        RAISE EXCEPTION 'ERROR: %', reason;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Test if the specified table exists or not.
 *
 * @param full_table_name	The full table name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__table_exists
    (
    full_table_name    TEXT
    ) 
RETURNS BOOLEAN AS 
'MODULE_PATHNAME', 'table_exists' 
LANGUAGE C IMMUTABLE;


/*
 * @brief Test if the specified column exists or not.
 *
 * @param full_table_name	The full table name.
 *
 * @return True if the column exists, otherwise return false.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__column_exists
    (
    full_table_name   TEXT,
    column_name       TEXT
    ) 
RETURNS BOOLEAN AS $$
DECLARE
    curstmt         TEXT := '';
    result          INT  := 0;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            (full_table_name IS NOT NULL) AND (column_name IS NOT NULL), 
            'the table name and column name must not be null'
        );
                
    IF (MADLIB_SCHEMA.__table_exists(full_table_name)) THEN
        SELECT MADLIB_SCHEMA.__format
            (
                'SELECT COUNT(*) 
                 FROM pg_catalog.pg_attribute 
                 WHERE attnum > 0 AND 
                       (NOT attisdropped) AND
                       attname = ''%'' AND
                       attrelid = ''%''::regclass',
                ARRAY[
                    column_name,
                    full_table_name
                ]
            ) INTO curstmt;
            
        EXECUTE curstmt INTO result;
        
        RETURN result >= 1;         
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Assert if the specified table exists or not.
 *
 * @param full_table_name	The full table name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__assert_table
    (
    full_table_name      TEXT,
    existence            BOOLEAN
    ) 
RETURNS void AS $$
DECLARE
    err_msg     TEXT;
BEGIN
    IF (existence) THEN
        err_msg = 'assertion failure. Table: ''' || full_table_name || 
                  ''' does not exist';
    ELSE
        err_msg = 'assertion failure. Table: ''' || full_table_name || 
                  ''' already exists';
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert
        (
            MADLIB_SCHEMA.__table_exists(full_table_name) = existence, 
            err_msg
        );
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the unknown values processing routine id. 
 *
 * @param tree_table    The full name of the tree table.
 *
 * @return The encoded missing value processing routine id.
 *
 */     
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_routine_id
    (
    tree_table TEXT 
    ) 
RETURNS INT AS $$
DECLARE
    name TEXT;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
    (
        'MADLIB_SCHEMA.training_info',
        't'
    );
        
    SELECT how2handle_missing_value 
    FROM   MADLIB_SCHEMA.training_info 
    WHERE  result_table_oid = tree_table::regclass 
    INTO   name;
        
    IF (name = 'ignore') THEN
        RETURN 1;
    ELSIF (name = 'explicit') THEN
        RETURN 2;
    ELSE
        RAISE EXCEPTION '__get_routine_id: %', name; 
    END IF;
    
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief  Strip the schema name from the full table name.
 *
 * @param full_table_name   The full table name. 
 *
 * @return The table name without schema name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__strip_schema_name
    (
    full_table_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    str_val TEXT;
BEGIN
     PERFORM MADLIB_SCHEMA.__assert
        (
            full_table_name IS NOT NULL, 
            'table name should not be null'
        );


    str_val = trim(both ' ' FROM split_part(full_table_name, '.', 2));

    IF (length(str_val) = 0) THEN
        str_val = btrim(full_table_name, ' ');
    END IF;

    RETURN lower(str_val);
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the schema name from a full table name.
 *        if there is no schema name in the full table name, then
 *        if the table exists, we return the schema name from catalog
 *        else the current schema name,
 *        else return the schema name from the full table name directly.
 *
 * @param full_table_name   The full table name.
 *
 * @return The schema name of the table.
 *
 */       
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_schema_name
    (
    full_table_name TEXT
    ) 
RETURNS TEXT AS $$
DECLARE
    table_name          TEXT;
    temp                TEXT[];
    len                 INT;
    curstmt             TEXT;
    schema_name         TEXT;
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            full_table_name IS NOT NULL, 
            'table name should not be null'
        );

    temp = string_to_array(full_table_name, '.');
    len = array_upper(temp, 1);

    IF (1 = len) THEN
        -- if table exists, return the schema name from catalog
        IF (MADLIB_SCHEMA.__table_exists(full_table_name)) THEN
            SELECT nspname 
            FROM pg_catalog.pg_namespace n
            WHERE n.oid = 
             (
                 SELECT relnamespace FROM pg_catalog.pg_class
                 WHERE oid= full_table_name::regclass
             )
                         
            INTO schema_name; 
        ELSE
            -- get the current schema name
            schema_name = current_schema();
        END IF;
    ELSE
        PERFORM MADLIB_SCHEMA.__assert
            (
                len = 2, 
                'wrong full table name<' || full_table_name || '>'
            );
        -- get the shema name directly 
        schema_name = lower(btrim(temp[1], ' '));    
    END IF;
    
    RETURN schema_name;
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Check if the input table has unsupported data type or not;
 * 		  Check if the id column of input table has duplicated value or not.
 *
 * @param full_table_name     The full table name.
 * @param feature_columns     The array including all feature names.
 * @param id_column           The name of the ID column.        
 * @param class_column        The name of the class column. 
 *
 * @return If the table has unsupported data types, then raise exception
 *         otherwise return nothing.
 *
 */    
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    )
RETURNS void AS $$  
DECLARE
    rec             RECORD;
    stmt            TEXT;
    all_columns     TEXT := '';
    index           INT;
BEGIN
    -- find the first (LIMIT 1) unsupported data type if the input table has.
    stmt= 'SELECT atttypid 
    FROM pg_attribute 
    WHERE attrelid ='||quote_literal(full_table_name)||'::regclass  AND
          attnum > 0                                                AND 
          (not attisdropped)                                        AND
          atttypid NOT IN 
          (
              SELECT unnest
                    (
                        ARRAY[
                            ''SMALLINT''::regtype::oid,
                            ''INT''::regtype::oid, 
                            ''BIGINT''::regtype::oid, 
                            ''FLOAT8''::regtype::oid, 
                            ''REAL''::regtype::oid, 
                            ''DECIMAL''::regtype::oid,
                            ''INET''::regtype::oid, 
                            ''CIDR''::regtype::oid, 
                            ''MACADDR''::regtype::oid, 
                            ''BOOLEAN''::regtype::oid, 
                            ''CHAR''::regtype::oid, 
                            ''VARCHAR''::regtype::oid, 
                            ''TEXT''::regtype::oid, 
                            ''"char"''::regtype::oid, 
                            ''DATE''::regtype::oid, 
                            ''TIME''::regtype::oid,
                            ''TIMETZ''::regtype::oid, 
                            ''TIMESTAMP''::regtype::oid, 
                            ''TIMESTAMPTZ''::regtype::oid, 
                            ''INTERVAL''::regtype::oid
                        ]
                    )
          ) ';

    IF (feature_columns IS NOT NULL) THEN
        -- If user do not specify feature columns, we use all those columns.
        -- Otherwise, we just need to check those specified columns.
        index = array_lower(feature_columns, 1);
        WHILE (index <= array_upper(feature_columns, 1)) LOOP
            all_columns = all_columns                           || 
                          quote_literal(feature_columns[index]) || 
                          ',';
            index = index+1;
        END LOOP; 
        
        all_columns = all_columns || quote_literal(id_column) || ',';
        all_columns = all_columns || quote_literal(class_column);
        stmt = stmt ||' AND attname IN ('||all_columns||') ';
    END IF;
    
    stmt = stmt||' LIMIT 1;';
    
    EXECUTE stmt INTO rec;
            
    IF (rec IS NOT NULL) THEN
        -- Print the first unsupported data type, and supported types.
        RAISE EXCEPTION 'Unsupported data type [%]. Supported types include:
                         SMALLINT, INT, BIGINT, FLOAT8, REAL,
                         DECIMAL, INET, CIDR, MACADDR, BOOLEAN,
                         CHAR, VARCHAR, TEXT, "char", 
                         DATE, TIME, TIMETZ, TIMESTAMP, TIMESTAMPTZ, and INTERVAL', 
                         rec.atttypid::regtype;
    END IF;

    SELECT MADLIB_SCHEMA.__format
            ('SELECT % AS n
              FROM % 
              GROUP BY %
              HAVING COUNT(%) > 1
              LIMIT 1',
              ARRAY[
                id_column,
                full_table_name,
                id_column,
                id_column
                ]
            )
    INTO stmt;
    
    EXECUTE stmt INTO rec;
    
    -- check if the id column has duplicated value
    PERFORM MADLIB_SCHEMA.__assert
                (
                    rec IS NULL,
                    'The training table ' || full_table_name || ' must not have duplicated id'
                );
                        
    RETURN;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Test if the given column is a continuous one or not.
 *
 * @param column_name           The name of the column.
 * @param cont_column_names     The array contains all the 
 *                              continuous column names.
 * 
 * @return True if the specified column is continuous, otherwise return false.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_continuous 
    (
    column_name         TEXT,
    cont_column_names   TEXT[]
    )
RETURNS BOOLEAN AS $$
DECLARE
    curstmt TEXT := '';
BEGIN
    IF (cont_column_names IS NOT NULL) THEN  
        FOR i IN 1..array_upper(cont_column_names, 1) LOOP
            IF (cont_column_names[i] = column_name) THEN
                RETURN 't';
            END IF;
        END LOOP; 
    END IF;
    
    RETURN 'f';
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Convert a string with delimiter ',' to an array.  
 *
 * @param csv_str   The string with elements delimited by ','.
 *
 * @return The splitting string array.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__csvstr_to_array 
    (
    csv_str TEXT
    )
RETURNS TEXT[] AS $$
DECLARE
    ret     TEXT[];
    str_val TEXT;
    index   INTEGER;
BEGIN
    ret = string_to_array(lower(csv_str), ',');
    
    IF (ret IS NOT NULL) THEN
        FOR index IN 1..array_upper(ret, 1) LOOP
            ret[index] = btrim(ret[index], ' ');
        END LOOP;
    END IF;

    RETURN ret;
END
$$ LANGUAGE PLPGSQL;
