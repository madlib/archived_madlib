-- Create the necessary tables for storing training data

-- document representations
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_document CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_document (id integer,text text);

-- tokenized document
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_segmenttbl CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_segmenttbl (start_pos integer,doc_id integer,seg_text text, max_pos integer);

-- CRF features
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_dictionary CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_dictionary (token text,token_id integer,label text,count integer,total integer);
 
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_feature CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_feature (id integer,name text,prev_label_id integer,label_id integer,weight float);

-- label space
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_label CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_label (id integer,label character varying);

-- lexicon table
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_lexicon CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_lexicon (id integer,filename text,lexicon text);

-- regex table
DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_regex CASCADE;
CREATE TABLE MADLIB_SCHEMA.textfex_regex (pattern text,name text);

-- R factor table
DROP TABLE IF EXISTS MADLIB_SCHEMA.viterbi_rtbl CASCADE;
CREATE TABLE MADLIB_SCHEMA.viterbi_rtbl (seg_text text, label integer, score real);

-- M factor table
DROP TABLE IF EXISTS MADLIB_SCHEMA.viterbi_mtbl CASCADE;
CREATE TABLE MADLIB_SCHEMA.viterbi_mtbl (
        score integer[]
);
   
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.textfex_generatemrtbl(integer, boolean) RETURNS void AS $$
DECLARE nlabel int;
        start_feature real[];
BEGIN
        -- calcuate the number of labels in the label space
        SELECT COUNT(*) INTO nlabel FROM textfex_label;

        -- insert unique tokens into the segment_hashtbl
        DROP TABLE IF EXISTS textfex_segment_hashtbl;
	CREATE TEMP TABLE textfex_segment_hashtbl(seg_text text);
        IF $2 = TRUE THEN 
		INSERT INTO textfex_segment_hashtbl(seg_text)
		((SELECT DISTINCT seg_text
		  FROM   textfex_segmenttbl
		  WHERE  doc_id = $1)
		 EXCEPT
		 (SELECT DISTINCT seg_text
		  FROM   textfex_segmenttbl
		  WHERE  doc_id <> $1)
		);
        ELSE 
		INSERT INTO textfex_segment_hashtbl(seg_text)
		SELECT DISTINCT seg_text
		FROM   textfex_segmenttbl;
        END IF; 

	-- generate M factor table
	DROP TABLE IF EXISTS textfex_mtbl;
	CREATE TEMP TABLE textfex_mtbl (
                        prev_label integer,
                        label integer,
			value double precision
			);

	-- generate temp label table
	DROP TABLE IF EXISTS prev_textfex_label;
	CREATE TEMP TABLE prev_textfex_label (id integer);

        -- add -1 to temp_textfex_label 
        INSERT INTO prev_textfex_label(id)
        SELECT textfex_label.id
        FROM   textfex_label;
        INSERT INTO prev_textfex_label VALUES(-1);
        INSERT INTO prev_textfex_label VALUES(nlabel);

        -- generate sparse M factor table
        INSERT INTO textfex_mtbl(prev_label, label, value)
        SELECT prev_label.id, label.id, 0 
        FROM   textfex_label as label,
               prev_textfex_label as prev_label;

        -- edgeFeature and startFeature, startFeature can be considered as a special edgeFeature  
        INSERT INTO textfex_mtbl(prev_label, label, value)
        SELECT prev_label_id,label_id,weight
	FROM   textfex_feature AS features
	WHERE  features.prev_label_id<>-1 OR features.name = 'S.';

        --endFeature, endFeature can be considered as a special edgeFeature
        INSERT INTO textfex_mtbl(prev_label, label, value)
        SELECT nlabel,label_id,weight
	FROM   textfex_feature AS features
	WHERE  features.name = 'End.';

        INSERT INTO viterbi_mtbl
        SELECT pg_catalog.array_agg(weight)
        FROM   (SELECT prev_label, label, (SUM(value)*1000)::integer AS weight
	        FROM   textfex_mtbl
                GROUP BY prev_label,label
                ORDER BY prev_label,label) as TEMP_MTBL;
        --GROUP BY prev_label, label;

        -- generate a sparse matrix to store the r factors
	DROP TABLE IF EXISTS textfex_rtbl;
	CREATE TEMP TABLE textfex_rtbl (
			seg_text text NOT NULL,
			label integer,
			value double precision
			);
	INSERT INTO textfex_rtbl(seg_text, label, value)
	SELECT segment_hashtbl.seg_text, labels.id, 0
	FROM   textfex_segment_hashtbl segment_hashtbl, 
	       textfex_label as labels
	GROUP BY segment_hashtbl.seg_text,labels.id;

	-- RegExFeature
	INSERT INTO textfex_rtbl(seg_text, label, value)
	SELECT segment_hashtbl.seg_text, features.label_id, features.weight
	FROM   textfex_segment_hashtbl AS segment_hashtbl, 
	       textfex_feature AS features, 
	       textfex_regex AS regex
	WHERE  segment_hashtbl.seg_text ~ regex.pattern
	       AND features.name||'%' ='R_' || regex.name
	GROUP BY segment_hashtbl.seg_text, features.label_id, features.weight;

        -- LexiconFeature
       INSERT INTO textfex_rtbl(seg_text, label, value)
       SELECT segment_hashtbl.seg_text, features.label_id, features.weight
       FROM   textfex_segment_hashtbl AS segment_hashtbl, 
              textfex_feature AS features
       WHERE  features.name = 'L_' || 
              (SELECT filename FROM textfex_lexicon WHERE lexicon = upper(segment_hashtbl.seg_text) LIMIT 1)
       GROUP BY segment_hashtbl.seg_text, features.label_id, features.weight;
       
        IF $2 = TRUE THEN
		-- unknownFeature
		INSERT INTO textfex_rtbl(seg_text, label, value)
		SELECT segment_hashtbl.seg_text, features.label_id, features.weight
		FROM   textfex_segment_hashtbl AS segment_hashtbl,
		       textfex_feature AS features
		WHERE  features.name = 'U'
		GROUP BY segment_hashtbl.seg_text, features.label_id, features.weight;
        
        ELSE
                -- create a temp partial dictionary table which stores the words whose occurance 
                -- is above certain threshold.
		-- refer to the CRF Package
		DROP TABLE IF EXISTS textfex_known_token;
		CREATE TEMP TABLE textfex_known_token (
				token text NOT NULL
				);

		INSERT INTO textfex_known_token
		SELECT DISTINCT token
		FROM   textfex_dictionary
		WHERE  textfex_dictionary.total>1;

		-- unknownFeature and word feature
		INSERT INTO textfex_rtbl(seg_text, label, value)
		SELECT segment_hashtbl.seg_text, features.label_id, features.weight
		FROM   textfex_segment_hashtbl AS segment_hashtbl,
		       textfex_feature AS features
		WHERE  (features.name = 'U'
		        AND lower(segment_hashtbl.seg_text) NOT IN (select token from textfex_known_token)) OR
		       (features.name = 'W_' || segment_hashtbl.seg_text)
		GROUP BY segment_hashtbl.seg_text, features.label_id, features.weight;

        END IF;

	-- Factor table
	INSERT INTO viterbi_rtbl(seg_text, label, score)
	SELECT seg_text,label,SUM(value) AS score
	FROM   textfex_rtbl
	GROUP BY seg_text,label;

        IF $2 = TRUE THEN
		-- insert the new sentence to the viterbi_segmenttbl
		INSERT INTO viterbi_segmenttbl(doc_id, seg_id, start_pos, seg_text,max_pos)
		SELECT doc_id,-1,start_pos,seg_text,max_pos
		FROM   textfex_segmenttbl
		WHERE  doc_id = $1;
		analyze viterbi_segmenttbl;
        ELSE
		-- insert the all sentences in the training dataset to the viterbi_segmenttbl
		INSERT INTO viterbi_segmenttbl(doc_id, seg_id, start_pos, seg_text, max_pos)
		SELECT doc_id,-1,start_pos,seg_text,max_pos
		FROM   textfex_segmenttbl;
		analyze viterbi_segmenttbl;
        END IF;
	DROP TABLE IF EXISTS textfex_rtbl;
	DROP TABLE IF EXISTS textfex_segment_hashtbl; 

END
$$ LANGUAGE plpgsql;
