/* ----------------------------------------------------------------------- *//**
 *
 * @file textfex.sql_in
 *
 * @brief this function is for text feature extraction. It supports two modes: batch mode and interactive mode.
 *     In batch mode, it extracts features for more than one sentences which stores in the segmentbl.
 *     In interactive mode, it extracts features for one sentence specified by the docId
 *
 * @param segmenttbl table representation of sentences
 * @param dictionary all the tokens which appear in the training data set
 * @param labeltbl the label space used in POS or other NLP tasks
 * @param regextbl all the regular expressions to capture regex features
 * @param viterbi_mtbl 
 * @param viterbi_rtbl
 * @param docId  if docId =-1 then it is in batch mode else it is in interactive mode, docId is the id of the sentence to be extracted features
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_texfex

@about this module does feature extraction implemented in plpython.

@implementation

-# At present, we implement six feature types
    - Edge Feature
    - Start Feature
    - End Feature
    - Word Feature
    - Unknown Feature
    - Regex Feature
you can add your own feature type according to the training model

@input

-# Prepare an input segmenttbl, e.g.:
- CREATE TABLE segmenttbl (start_pos integer,doc_id integer,seg_text text, max_pos integer)
- COPY segmenttbl FROM "/path/to/data/segmenttbl.tab"
sql> select * from segmenttbl order by doc_id, start_pos;
start_pos | doc_id | seg_text      | max_pos
----------+---------+--------------+-------------
     0    |    1   |       madlib  |    9  
     1    |    1   |           is  |    9
     2    |    1   |           an  |    9
     3    |    1   |  open-source  |    9
     4    |    1   |      library  |    9
     5    |    1   |          for  |    9
     6    |    1   |     scalable  |    9
     7    |    1   |  in-database  |    9
     8    |    1   |    analytics  |    9
     9    |    1   |            .  |    9
     0    |    2   |           it  |   16    
     1    |    2   |     provides  |   16
     2    |    2   |data-parallel  |   16
     3    |    2   |implementations|   16
     ... 
     14   |    2   |  unstructured |   16
     15   |    2   |          data |   16
     16   |    2   |             . |   16

-# Prepare an input """ + dictionary + """ table, e.g.:
- CREATE TABLE dictionary (token text,token_id integer,label text,count integer,total integer)
- COPY dictionary FROM "/path/to/data/dictionary.tab"
\verbatim
sql> select * from """ + dictionary + """;
token       | label  | count | total
------------+--------+--------------
   freefall |   11   |   1   |  1
     policy |   11   |   2   |  2
   measures |   12   |   1   |  1
 commitment |   11   |   1   |  1
        new |    6   |   1   |  1
     speech |   11   |   1   |  1
         's |   16   |   2   |  2
     reckon |   30   |   1   |  1
 underlying |   28   |   1   |  1
 ...
\endverbatim

-# Prepare an input label table, e.g.:
- CREATE TABLE labeltbl (id integer,label character varying)
- COPY labeltbl FROM "/path/to/data/labeltbl.tab"
\verbatim
sql> select * from """ + labeltbl + """ order by id;
id          | label
------------+--------
      0     |   CC   
      1     |   CD   
      2     |   DT
      3     |   EX
      4     |   FW
      5     |   IN
      6     |   JJ
...
     42     |    ,
     43     |    .
     44     |    :
\endverbatim

-# Prepare an input regex table, e.g.:
- CREATE TABLE regextbl (pattern text,name text)
- COPY regextbl FROM "/path/to/data/regextbl.tabl"
\verbatim
sql> select * from regex;
pattern       |   name
------------- +---------------
^[A-Z][a-z]+$ |  InitCapital%   
     ^[A-Z]+$ |  isAllCapital%
 ^.*[0-9]+.*$ |  containsDigit%
      ^.+[.]$ |  endsWithDot%
      ^.+[,]$ |  endsWithComma%
       ^.+er$ |  endsWithER%
      ^.+est$ |  endsWithEst%
       ^.+ed$ |  endsWithED%
...
\endverbatim

-# Prepare an input feature table, e.g.:
- CREATE TABLE featuretbl (id integer,name text,prev_label_id integer,label_id integer,weight float)
- COPY featuretbl FROM "path/to/data/featuretbl.tab"
\verbatim
sql> select * from feature order by id;
id   |     name     | prev_label_id | label_id | weight
-------------------------------------------------------
1    | W_chancellor |       -1      |    13     | 2.2322
2    |         E.13 |       13      |     5     | 2.3995
3    |            U |       -1      |     5     | 1.2164
4    |         W_of |       -1      |     5     | 2.8744
5    |          E.5 |        5      |     2     | 3.7716
6    |        W_the |       -1      |     2     | 4.1790
7    |          E.2 |        2      |    13     | 0.8957
...
\endverbatim

@implemenation
 this feature extraction function will produce two tables, m table and r table. The m table and r table are used to calucate
 the best label sequence for each sentence.
 - m table
 basically m table contains the edge features which are solely dependent on upon current label and previous 'y' value.
 m table has three colomuns which are prev_label, label, value respectively.
 if the number of labels in n, then the m factors table will n*n rows. Each row encodes the transition feature weight 
'value' from previous label to current label.
 startFeature is can be considered as a special edge feature which is from the very first to the first token
 endFeature can be considered as a special edege feature which is from the last token to the vey end.
 so m table encodes the edgeFeature, startFeature, endFeature.
 if the total number of labels in the label space are 45 from 0 to 44. then the m factors array is as follows:
                  0  1  2  3  4  5...44
 startFeature -1  a  a  a  a  a  a...a
 edgeFeature   0  a  a  a  a  a  a...a
 edgeFeature   1  a  a  a  a  a  a...a
 ...
 edgeFeature   44 a  a  a  a  a  a...a
 endFeature    45 a  a  a  a  a  a...a

 -r table
 r table is related to specific tokens. It encodes the single state features,eg., worldFeature, RegexFeature
 for all tokens. The r table is represented in the following way.
        0  1  2  3  4...44
 token1 a  a  a  a  a...a
 token2 a  a  a  a  a...a

 -advantage
 Instead of scanning every tokens in a sentence and extract features for each token on fly, 
 we extract features for each distinct token and prematerlized it in the table.
 When we call viterbi function to get the best label sequence, we only need to a single lookup to get the feature weight.

@usage 
  - Run feature extraction in batch mode
  <pre>SELECT __text_feature_extraction(
       '<em>segmenttbl<\em>',
       '<em>dictionary<\em>',
       '<em>labeltbl<\em>',
       '<em>regextbl<\em>',
       '<em>featuretbl<\em>',
       '<em>viterbi_mtbl<\em>',
       '<em>viterbi_rtbl<\em>'
       '<em>-1<\em>');</pre>
  This will do feature extraction for all the sentences in the segmenttbl
  <pre></pre>

  - Run feature extraction in interactive mode
  <pre>SELECT __text_feature_extraction(
       '<em>segmenttbl<\em>',
       '<em>dictionary<\em>',
       '<em>labeltbl<\em>',
       '<em>regextbl<\em>',
       '<em>featuretbl<\em>',
       '<em>viterbi_mtbl<\em>',
       '<em>viterbi_rtbl<\em>'
       '<em>sentence_id<\em>');</pre>
  This will do feature extraction for the sentence specified by the sentence_id in the segmenttbl
  <pre></pre>

@literature
[1] http://crf.sourceforge.net/ 
*/

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__text_feature_extraction(segmenttbl text, dictionary  text, labeltbl text, regextbl text, featuretbl text,
                                                                   viterbi_mtbl text, viterbi_rtbl text, document_id integer) RETURNS void AS 
$$
        plpy.execute("DROP TABLE IF EXISTS prev_labeltbl, segment_hashtbl, unknown_segment_hashtbl, rtbl, mtbl;")

        plpy.execute("CREATE TEMP TABLE prev_labeltbl(id int);")

        # Insert unique tokens into the segment_hashtbl
        plpy.execute("CREATE TEMP TABLE segment_hashtbl(seg_text text);")

        # create a temp partial dictionary table which stores the words whose occurance
        # is below certain threshold, refer to the CRF Package
        plpy.execute("CREATE TEMP TABLE unknown_segment_hashtbl(seg_text text);")

        # Generate a sparse matrix to store the r factors
        plpy.execute("CREATE TEMP TABLE rtbl (seg_text text NOT NULL, label integer, value double precision);")

        # Generate M factor table
        plpy.execute("CREATE TEMP TABLE mtbl(prev_label integer, label integer, value double precision);")

        # Calcuate the number of labels in the label space
        rv = plpy.execute("SELECT COUNT(*) AS total_label FROM " + labeltbl + ";")
        nlabel = rv[0]['total_label']

        if document_id != -1: 
        	plpy.execute("""INSERT INTO segment_hashtbl(seg_text)
		                ((SELECT DISTINCT seg_text
		                  FROM   """ + segmenttbl + """ 
		                  WHERE  doc_id = """ + str(document_id) + """) 
		                 EXCEPT 
		                 (SELECT DISTINCT seg_text 
		                  FROM   """ + segmenttbl + """ 
		                  WHERE  doc_id <> """ + str(document_id) + """));""")
                
                plpy.execute("""INSERT INTO unknown_segment_hashtbl(seg_text) 
                                SELECT seg_text 
                                FROM   segment_hashtbl;""")
        else: 
                plpy.execute("""INSERT INTO segment_hashtbl(seg_text) 
	             	        SELECT DISTINCT seg_text
		                FROM   """ + segmenttbl + """;""")

                plpy.execute("""INSERT INTO unknown_segment_hashtbl(seg_text) 
                                ((SELECT DISTINCT seg_text 
                                  FROM   segment_hashtbl) 
                                 EXCEPT
		                 (SELECT DISTINCT token 
		                  FROM   """ + dictionary + """ 
		                  WHERE  total>1));""")

        plpy.execute("""INSERT INTO prev_labeltbl
                        SELECT id
                        FROM   """ + labeltbl + """;
                        INSERT INTO prev_labeltbl VALUES(-1); 
                        INSERT INTO prev_labeltbl VALUES( """ + str(nlabel) + """);""")

        # Generate sparse M factor table
        plpy.execute("""INSERT INTO mtbl(prev_label, label, value) 
                        SELECT prev_label.id, label.id, 0 
                        FROM   """ + labeltbl + """ AS label, 
                               prev_labeltbl as prev_label;""")

        # EdgeFeature and startFeature, startFeature can be considered as a special edgeFeature  
        plpy.execute("""INSERT INTO mtbl(prev_label, label, value) 
                        SELECT prev_label_id,label_id,weight
	                FROM   """ + featuretbl + """ AS features 
	                WHERE  features.prev_label_id<>-1 OR features.name = 'S.';""")

        # EndFeature, endFeature can be considered as a special edgeFeature
        plpy.execute("""INSERT INTO mtbl(prev_label, label, value) 
                        SELECT """ + str(nlabel) + """, label_id, weight
	                FROM   """ + featuretbl + """ AS features 
	                WHERE  features.name = 'End.';""")

        plpy.execute("""INSERT INTO viterbi_mtbl
                        SELECT array_agg(weight ORDER BY prev_label,label) 
                        FROM   (SELECT prev_label, label, (SUM(value)*1000)::integer AS weight 
	                        FROM   mtbl
                                GROUP BY prev_label,label
                                ORDER BY prev_label,label) as TEMP_MTBL;""")

	plpy.execute("""INSERT INTO rtbl(seg_text, label, value) 
	                SELECT segment_hashtbl.seg_text, labels.id, 0 
	                FROM   segment_hashtbl segment_hashtbl, 
	                 """ + labeltbl + """ AS labels;""")

	# RegExFeature
	plpy.execute("""INSERT INTO rtbl(seg_text, label, value) 
	                SELECT segment_hashtbl.seg_text, features.label_id, features.weight 
	                FROM   segment_hashtbl AS segment_hashtbl, 
	                 """ + featuretbl + """ AS features,
	                 """ + regextbl + """ AS regex
	                WHERE  segment_hashtbl.seg_text ~ regex.pattern 
	                       AND features.name||'%' ='R_' || regex.name;""")

	# UnknownFeature
	plpy.execute("""INSERT INTO rtbl(seg_text, label, value) 
	                SELECT segment_hashtbl.seg_text, features.label_id, features.weight 
	                FROM   unknown_segment_hashtbl AS segment_hashtbl, 
	                 """ + featuretbl + """ AS features 
	                WHERE  features.name = 'U';""")

	# Wordfeature
        if document_id == -1:
		plpy.execute("""INSERT INTO rtbl(seg_text, label, value) 
	                        SELECT seg_text, label_id, weight 
	                        FROM   segment_hashtbl, 
		                """  + featuretbl + """ 
                                WHERE  name = 'W_' || seg_text;""")

	# Factor table
	plpy.execute("""INSERT INTO """ + viterbi_rtbl + """(seg_text, label, score) 
	                SELECT seg_text,label,(SUM(value)*1000)::integer AS score 
	                FROM   rtbl
	                GROUP BY seg_text,label;""")

$$ LANGUAGE plpythonu STRICT;
