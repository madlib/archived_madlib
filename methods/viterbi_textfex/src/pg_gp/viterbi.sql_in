--! \file viterbi.sql_in
--!
--! * Basic usage
--! \code
--!   -- Compute the Max-Likelihood segmentation for each document.
--!   select MADLIB_SCHEMA.vcrf_label('enron.segments', 'enron.m_factors', 'enron.r_factors', 'enron.labels', 'enron.extraction', 'enron', 'e');
--!
--!   -- Examine the view
--!   select * from enron.extraction;
--! \endcode

m4_include(`SQLCommon.m4')

-- a human readable view of the segmentation output table
create or replace function MADLIB_SCHEMA.__vcrf_top1_view (segtbl text, labeltbl text, result_tbl text, vw text) returns text AS
$$
rv = plpy.execute('SELECT COUNT(*) AS total FROM ' + labeltbl);
nlabel = rv[0]['total']
query = 'create view ' + vw + ' AS ' + \
' select segs.doc_id, start_pos, seg_text, L.label, (exp((result.label[max_pos+2] - result.label[max_pos+3])::float/1000)) as prob ' + \
' from ' + segtbl + ' segs, ' + labeltbl + ' L, ' + \
' ' + result_tbl + ' result ' + \
' where result.label[segs.start_pos+1]=L.id and segs.doc_id=result.doc_id' + \
' order by doc_id, start_pos;'
plpy.execute(query)
return vw
$$ language plpythonu strict;

-- create C-UDF functions for finding optimal sequence label using viterbi algorithm
create or replace function MADLIB_SCHEMA.__vcrf_top1_label(int[], int[], int[], int)
returns int[] as 'MODULE_PATHNAME' language c strict;

--! \examp
--! select __vcrf_top1(doc_id) from doc_ids where doc_id=1;
---------------------------------------------------------------
-- UDF: __vcrf_top1(segtbl, docid int)
-- usage: compute top1 labelings for a document
-- input: doc_id
-- output: output file name
----------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__vcrf_top1(segtbl text, mfactortbl text, rfactortbl text, labeltbl text, docs text, resulttbl text) RETURNS int AS
$$
rv = plpy.execute('SELECT COUNT(*) AS total FROM ' + labeltbl);
nlabel = rv[0]['total']

plpy.execute(' INSERT INTO ' + resulttbl + \
             ' SELECT segs.doc_id, MADLIB_SCHEMA.__vcrf_top1_label(segs.seglist, mfactors.score, rfactors.score, ' + str(nlabel) + ' ) '  + \
	     ' FROM '  + segtbl + ' segs, ' + mfactortbl + ' mfactors, ' + rfactortbl + ' rfactors ' + ' ;') 
return 0 
$$ LANGUAGE plpythonu STRICT;

create or replace function
MADLIB_SCHEMA.vcrf_label(segtbl text, factor_mtbl text, factor_rtbl text, labeltbl text, resulttbl text, schemaname text, prefix text)   RETURNS text AS
  $$
  seq = prefix + "_seqno"
  seglook = schemaname + "." + prefix + "_segment_lookup"
  segs = schemaname + "." + prefix + "_segments"
  segstbl = schemaname + "." + prefix + "_segmentbl"
  m_factors = schemaname + "." + prefix + "_m_factors"
  r_factors = schemaname + "." + prefix + "_r_factors"
  norm_factors = schemaname + "." + prefix + "_norm_factors"
  doc_ids = schemaname + "." + prefix + "_doc_ids"
  resulttbl_raw = resulttbl + "_raw"

  query = "DROP SEQUENCE IF EXISTS " + seq + " cascade;"
  plpy.execute(query);
  query = "DROP TABLE IF EXISTS " +seglook+"," +segs+","+m_factors+","+r_factors+","+norm_factors+","+doc_ids+","+resulttbl_raw +";"
  plpy.execute(query);

  retval = {}
  retval["segments"] = segs
  retval["segmentstbl"] = segstbl
  retval["m_factors"] = m_factors
  retval["r_factors"] = r_factors
  retval["doc_ids"] = doc_ids
  retval["norm_factors"] = norm_factors
  retval["segment_lookup"] = seglook
  retval["norm_factors"] = norm_factors
  retval["result_table"] = resulttbl

  query = """
  -- assign IDs to distinct segments.
  -- uses input: segtbl
  create temp sequence """ + seq + ";"

  plpy.execute(query)

  query = """
    select seg_text, nextval(\'""" + seq + """\') as seg_id
      into """ + seglook + """
      from (select distinct(seg_text)
              from """ + segtbl + ") as A;"

  plpy.execute(query)

  query = "analyze " + seglook + ";"

  plpy.execute(query);

  query = """
  -- tag ids onto input segments and store result in vcrf_segments
  -- uses input: segtbl
  select doc_id, pg_catalog.array_agg(seg_id) as seglist
  -- select doc_id, start_pos, SH.seg_id
    into """ + segs + """
    from (select doc_id, SH.seg_id::integer as seg_id
          from """ + segtbl + """ S,
               """ + seglook + """ SH
          where S.seg_text=SH.seg_text
          group by doc_id, start_pos, SH.seg_id
          order by doc_id, start_pos, SH.seg_id) as ss
     group by doc_id;"""

  plpy.execute(query)
  query = "analyze " + segs + ";"

  query = """
  -- tag ids onto input segments and store result in vcrf_segments
  -- uses input: segtbl
     select doc_id, start_pos, SH.seg_id::integer as seg_id, SH.seg_text, max_pos
     into """ + segstbl + """
     from """ + segtbl + """ S,
          """ + seglook + """ SH
     where S.seg_text=SH.seg_text
     group by doc_id, start_pos, SH.seg_id, SH.seg_text, max_pos
     order by doc_id, start_pos, SH.seg_id, SH.seg_text, max_pos;"""
  plpy.execute(query);
  query = "analyze " + segstbl + ";"

  query = """
  -- for each seg_id, store array representation of max r_factor-score * 1000
  select pg_catalog.array_agg(score) as score
    into """ + r_factors + """
    from (select seg_id, (score*1000)::integer as score
          from """ + factor_rtbl + """ factors,
                 """ + seglook + """ SH
          where factors.seg_text=SH.seg_text
          order by seg_id, label) as ss;"""
  
  plpy.execute(query)

  query = """
  -- for each seg_id, store array representation of max r_factor-score * 1000
  select score
    into """ + m_factors + """
    from (select score
          from """ + factor_mtbl + """ factors) as ss; """

  plpy.execute(query)

  query = """
  -- distinct doc_ids
  select distinct(doc_id) as doc_id
  into """ + doc_ids + """
  from """ + segs + """;
  analyze """ + doc_ids + ";"
  plpy.execute(query);

  query = "CREATE TABLE " + resulttbl_raw + " (doc_id integer, label integer[]);"
  plpy.execute(query);

  query = """
  select madlib.__vcrf_top1(\'""" + segs + """\',
                            \'""" + m_factors + """\',
                            \'""" + r_factors + """\',
                            \'""" + labeltbl + """\',
                            \'""" + doc_ids + """\',
                            \'""" + resulttbl_raw + """\')"""
  plpy.execute(query);
 
  query = "SELECT * FROM MADLIB_SCHEMA.__vcrf_top1_view(\'" + segstbl + "\', \'" + labeltbl + "\', \'" + resulttbl_raw + "\', \'" + resulttbl + "\');"
  plpy.execute(query);
   
$$ LANGUAGE plpythonu STRICT;
