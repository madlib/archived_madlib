--! \file viterbi.sql_in
--!
--! * Basic usage
--! \code
--!   -- Compute the Max-Likelihood segmentation for each document.
--!   select MADLIB_SCHEMA.vcrf_label('enron.segments_with_dup', 'enron.factors_with_dup', 'enron.labels', 'enron.extraction', 'enron', 'e');
--!
--!   -- Examine the view
--!   select * from enron.extraction;
--! \endcode

m4_include(`SQLCommon.m4')

-- create C-UDF functions for array manipulations
create or replace function MADLIB_SCHEMA.__vcrf_top1_label(anyarray, anyarray, anyarray, anyelement)
returns anyarray as 'MODULE_PATHNAME' language c strict;

create or replace function MADLIB_SCHEMA.__vcrf_sum_array(anyarray, anyarray, anyarray, anyelement, anyelement)
returns anyarray as 'MODULE_PATHNAME' language c strict;

create or replace function MADLIB_SCHEMA.__vcrf_sum(anyarray)
returns integer as 'MODULE_PATHNAME' language c strict;

--! \examp
--! select normalization(doc_id) from doc_ids where doc_id=1;
---------------------------------------------------------------
-- UDF: normalization(segtbl, factortbl, docid int)
-- usage: compute normalization factor for a given document
-- input: doc_id
-- output: normalization factor
----------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__vcrf_top1(segtbl text, mfactortbl text, rfactortbl text, labeltbl text, docs text, resulttbl text) RETURNS int AS
$$
rv = plpy.execute('SELECT COUNT(*) AS total FROM ' + labeltbl);
nlabel = rv[0]['total']

rv = plpy.execute('SELECT COUNT(*) AS total FROM '+docs); 
ndocs =rv[0]['total']

#for doc_id in range(1,ndocs+1):
for doc_id in range(1,2):
	rv = plpy.execute(' INSERT INTO ' + resulttbl + \
                          ' SELECT MADLIB_SCHEMA.__vcrf_top1_label(segs.seglist, mfactors.score, rfactors.score, ' + str(nlabel) + ' ) '  + \
			  ' FROM '  + segtbl + ' segs, ' + mfactortbl + ' mfactors, ' + rfactortbl + ' rfactors ' + \
                          ' WHERE doc_id = ' + str(doc_id) + ' ;')
return 0 
$$ LANGUAGE plpythonu STRICT;

create or replace function
MADLIB_SCHEMA.vcrf_label(segtbl text, factor_mtbl text, factor_rtbl text, labeltbl text, resulttbl text, schemaname text, prefix text)   RETURNS text AS
  $$
  seq = prefix + "_seqno"
  seglook = schemaname + "." + prefix + "_segment_lookup"
  segs = schemaname + "." + prefix + "_segments"
  m_factors = schemaname + "." + prefix + "_m_factors"
  r_factors = schemaname + "." + prefix + "_r_factors"
  norm_factors = schemaname + "." + prefix + "_norm_factors"
  display_segs = schemaname + "." + prefix + "_display_segments"
  doc_ids = schemaname + "." + prefix + "_doc_ids"
  resulttbl_raw = resulttbl + "_raw"

  query = "DROP SEQUENCE IF EXISTS " + seq + " cascade;"
  plpy.execute(query);
  query = "DROP VIEW IF EXISTS " + display_segs + " cascade;"
  plpy.execute(query);
  query = "DROP TABLE IF EXISTS " +seglook+"," +segs+","+m_factors+","+r_factors+","+norm_factors+","+doc_ids+","+resulttbl_raw +";"
  plpy.execute(query);

  retval = {}
  retval["segments"] = segs
  retval["m_factors"] = m_factors
  retval["r_factors"] = r_factors
  retval["doc_ids"] = doc_ids
  retval["norm_factors"] = norm_factors
  retval["display_segments"] = display_segs
  retval["segment_lookup"] = seglook
  retval["norm_factors"] = norm_factors
  retval["result_table"] = resulttbl

  query = """
  -- assign IDs to distinct segments.
  -- uses input: segtbl
  create temp sequence """ + seq + ";"

  plpy.execute(query)

  query = """
    select seg_text, nextval(\'""" + seq + """\') as seg_id
      into """ + seglook + """
      from (select distinct(seg_text)
              from """ + segtbl + ") as A;"

  plpy.execute(query)

  query = "analyze " + seglook + ";"

  plpy.execute(query);

  query = """
  -- tag ids onto input segments and store result in vcrf_segments
  -- uses input: segtbl
  select doc_id, pg_catalog.array_agg(seg_id) as seglist
  -- select doc_id, start_pos, SH.seg_id
    into """ + segs + """
    from (select doc_id, SH.seg_id::integer as seg_id
          from """ + segtbl + """ S,
               """ + seglook + """ SH
          where S.seg_text=SH.seg_text
          group by doc_id, start_pos, SH.seg_id
          order by doc_id, start_pos, SH.seg_id) as ss
     group by doc_id;"""

  plpy.execute(query)

  query = "analyze " + segs + ";"

  plpy.execute(query);

  query = """
  -- for each seg_id, store array representation of max r_factor-score * 1000
  select pg_catalog.array_agg(score) as score
    into """ + r_factors + """
    from (select seg_id, (score*1000)::integer as score
          from """ + factor_rtbl + """ factors,
                 """ + seglook + """ SH
          where factors.seg_text=SH.seg_text
          order by seg_id, label) as ss;"""
  
  plpy.execute(query)

  query = """
  -- for each seg_id, store array representation of max r_factor-score * 1000
  select score
    into """ + m_factors + """
    from (select score
          from """ + factor_mtbl + """ factors) as ss; """

  plpy.execute(query)

  #query = """
  #create index """ + prefix + """_factors_seg_id on """ + r_factors + """(seg_id);
  #analyze """ + r_factors + ";"
  #plpy.execute(query);

  query = """
  -- distinct doc_ids
  select distinct(doc_id) as doc_id
  into """ + doc_ids + """
  from """ + segs + """;
  analyze """ + doc_ids + ";"

  plpy.execute(query);

  #query = "CREATE TABLE " + resulttbl_raw + " (doc_id integer, start_pos integer, seg_id integer, label integer, score integer);"
  query = "CREATE TABLE " + resulttbl_raw + " (label integer[]);"
  plpy.execute(query);
  query = """
  select madlib.__vcrf_top1(\'""" + segs + """\',
                            \'""" + m_factors + """\',
                            \'""" + r_factors + """\',
                            \'""" + labeltbl + """\',
                            \'""" + doc_ids + """\',
                            \'""" + resulttbl_raw + """\')"""
  plpy.execute(query);
$$ LANGUAGE plpythonu STRICT;
