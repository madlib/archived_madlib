/* ----------------------------------------------------------------------- *//**
 *
 * @file model_loader.sql_in
 *
 * @brief create all the necessary tables to store the trained model, then import the trained models to the tables
 * @date Feb. 2012
 * @sa For an introduction to the text feature extraction, see the module
 *     description \ref grp_textfex.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_textfex

@input
The <b>textfex_document</b> is expected to be of the following form:
<pre>{TABLE|VIEW} <em>textfex_documents</em> (
*/

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__load_crf_model() RETURNS void AS 
$$
        # document table
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_document;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_document (id integer,text text);"
	plpy.execute(query);

        # tokenized document
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_segmenttbl;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_segmenttbl (start_pos integer,doc_id integer,seg_text text, max_pos integer)";
	plpy.execute(query);

	# CRF features
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_dictionary;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_dictionary (token text,token_id integer,label text,count integer,total integer)";
	plpy.execute(query);

	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_feature;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_feature (id integer,name text,prev_label_id integer,label_id integer,weight float)";
	plpy.execute(query);

	# label space
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_label CASCADE;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_label (id integer,label character varying)";
	plpy.execute(query);

	# regex table
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.textfex_regex;" + \
	        "CREATE TABLE MADLIB_SCHEMA.textfex_regex (pattern text,name text)";
	plpy.execute(query);

	# R factor table
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.viterbi_rtbl;" + \
	        "CREATE TABLE MADLIB_SCHEMA.viterbi_rtbl (seg_text text, label integer, score integer)";
	plpy.execute(query);

	# M factor table
	query = "DROP TABLE IF EXISTS MADLIB_SCHEMA.viterbi_mtbl;" + \
	        "CREATE TABLE MADLIB_SCHEMA.viterbi_mtbl (score integer[])";
	plpy.execute(query);

	# Documents table
	query = "COPY MADLIB_SCHEMA.textfex_document (id ,text) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-documents.tab'";
	plpy.execute(query);

	# Features table
	query = "COPY MADLIB_SCHEMA.textfex_feature (id,name,prev_label_id,label_id,weight) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-features.tab'";
	plpy.execute(query);

	# Dictionary table
	query = "COPY MADLIB_SCHEMA.textfex_dictionary (token,token_id,label,count,total) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-dictionary.tab'";
	plpy.execute(query);

	# Regex table
	query = "COPY MADLIB_SCHEMA.textfex_regex (pattern,name) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-regex.tab'";
	plpy.execute(query);

	# Labels table
	query = "COPY MADLIB_SCHEMA.textfex_label (id,label) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-labels.tab'";
	plpy.execute(query);

	# Segment table
	query = "COPY MADLIB_SCHEMA.textfex_segmenttbl (start_pos,doc_id,seg_text,max_pos) FROM '/home/livingstream/Desktop/Dropbox/posinputMadlib/output/enron-segmenttbl.tab'";
	plpy.execute(query);

$$ language plpythonu STRICT;
