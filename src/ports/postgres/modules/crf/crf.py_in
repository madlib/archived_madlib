# coding=utf-8

"""
@file crf.py_in

@brief Conditional Random Field: Driver functions

@namespace logistic

Conditional Random Field: Driver functions
"""

import plpy

def __runIterativeAlg(stateType, initialState, source, updateExpr,
    terminateExpr, maxNumIterations, cyclesPerIteration = 1):
    
    updateSQL = """
        INSERT INTO _madlib_iterative_alg
        SELECT
            {{iteration}},
            {updateExpr}
        FROM
            _madlib_iterative_alg AS st,
            {{source}} AS src
        WHERE
            st._madlib_iteration = {{iteration}} - 1
        """.format(updateExpr = updateExpr)
    terminateSQL = """
        SELECT
            {terminateExpr} AS should_terminate
        FROM    
        (
            SELECT _madlib_state
            FROM _madlib_iterative_alg
            WHERE _madlib_iteration = {{iteration}} - {{cyclesPerIteration}}
        ) AS older,
        (
            SELECT _madlib_state
            FROM _madlib_iterative_alg
            WHERE _madlib_iteration = {{iteration}}
        ) AS newer
        """.format(terminateExpr = terminateExpr)
    checkForNullStateSQL = """
        SELECT _madlib_state IS NULL AS should_terminate
        FROM _madlib_iterative_alg
        WHERE _madlib_iteration = {iteration}
        """

    oldMsgLevel = plpy.execute("SELECT setting FROM pg_settings WHERE name='client_min_messages'"
        )[0]['setting']
    plpy.execute("""
        SET client_min_messages = error;
        DROP TABLE IF EXISTS _madlib_iterative_alg;
        CREATE TEMPORARY TABLE _madlib_iterative_alg (
            _madlib_iteration INTEGER PRIMARY KEY,
            _madlib_state {stateType}
        );
        SET client_min_messages = {oldMsgLevel};
        """.format(stateType = stateType, oldMsgLevel = oldMsgLevel))
    
    iteration = 0
    plpy.execute("""
        INSERT INTO _madlib_iterative_alg VALUES ({iteration}, {initialState})
        """.format(iteration = iteration, initialState = initialState))
    while True:
        iteration = iteration + 1
        plpy.execute(updateSQL.format(
            source = source,
            state = "(st._madlib_state)",
            iteration = iteration,
            sourceAlias = "src"))
        if plpy.execute(checkForNullStateSQL.format(
                iteration = iteration))[0]['should_terminate'] or (
            iteration > cyclesPerIteration and (
            iteration >= cyclesPerIteration * maxNumIterations or
            plpy.execute(terminateSQL.format(
                iteration = iteration,
                cyclesPerIteration = cyclesPerIteration,
                oldState = "(older._madlib_state)",
                newState = "(newer._madlib_state)"))[0]['should_terminate'])):
            break
    
    # Note: We do not drop the temporary table
    return iteration


def compute_lincrf(MADlibSchema, source, featureColumn, featureSize, tagSize, maxNumIterations, precision, **kwargs):
    if maxNumIterations < 1:
        plpy.error("Number of iterations must be positive")
    
    return __runIterativeAlg(
        stateType = "FLOAT8[]",
        initialState = "NULL",
        source = source,
        updateExpr = """
            {MADlibSchema}.lincrf_lbfgs_step(
                ({featureColumn})::FLOAT8[],
                ({featureSize})::FLOAT8,
                ({tagSize})::FLOAT8,
                {{state}}
            )
            """.format(
                MADlibSchema = MADlibSchema,
                featureColumn = featureColumn,
                featureSize = featureSize,
                tagSize = tagSize),
        terminateExpr = """
            {MADlibSchema}.internal_lincrf_lbfgs_converge(
                {{newState}}) = 0
            """.format(
                MADlibSchema = MADlibSchema),
        maxNumIterations = maxNumIterations)
