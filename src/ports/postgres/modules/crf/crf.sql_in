/* ----------------------------------------------------------------------- *//** 
 *
 * @file lincrf.sql_in
 *
 * @brief SQL functions for conditional random field
 * @date January 2011
 *
 * @sa For a brief introduction to conditional random field, see the
 *     module description \ref grp_lincrf.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_lincrf
@about
@input
@usage
@examp
@literature
@sa File lincrf.sql_in (documenting the SQL functions)
@sa Namespace logistic (documenting the driver/outer loop implemented in

*/

DROP TYPE IF EXISTS MADLIB_SCHEMA.lincrf_result;
CREATE TYPE MADLIB_SCHEMA.lincrf_result AS (
    coef DOUBLE PRECISION[],
    log_likelihood DOUBLE PRECISION,
    num_iterations INTEGER
);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.lincrf_lbfgs_step_transition(
    DOUBLE PRECISION[],
    DOUBLE PRECISION[],
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.lincrf_lbfgs_step_merge_states(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.lincrf_lbfgs_step_final(
    state DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.internal_lincrf_lbfgs_step_distance(
    /*+ state1 */ DOUBLE PRECISION[],
    /*+ state2 */ DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION AS
'MODULE_PATHNAME'
LANGUAGE c IMMUTABLE STRICT;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.internal_lincrf_lbfgs_result(
    /*+ state */ DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.lincrf_result AS
'MODULE_PATHNAME'
LANGUAGE c IMMUTABLE STRICT;

/**
 * @internal
 * @brief Perform one iteration of the L-BFGS method for computing
 * conditional random field
 */
CREATE AGGREGATE MADLIB_SCHEMA.lincrf_lbfgs_step(
    /*+ feature columns */ DOUBLE PRECISION[],
    /*+ feature size */ DOUBLE PRECISION,
    /*+ tag size */ DOUBLE PRECISION,
    /*+ previous_state */ DOUBLE PRECISION[]) (
    
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.lincrf_lbfgs_step_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.lincrf_lbfgs_step_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.lincrf_lbfgs_step_final,
    INITCOND='{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.array_union(anyarray) (
    SFUNC = array_cat, 
    STYPE = anyarray
); 

-- We only need to document the last one (unfortunately, in Greenplum we have to
-- use function overloading instead of default arguments).
CREATE FUNCTION MADLIB_SCHEMA.compute_lincrf(
    "source" VARCHAR,
    "featureColumn" VARCHAR,
    "featureSize" VARCHAR,
    "tagSize" INTEGER,
    "maxNumIterations" INTEGER,
    "precision" DOUBLE PRECISION)
RETURNS INTEGER
AS $$PythonFunction(crf, crf, compute_lincrf)$$
LANGUAGE plpythonu VOLATILE;

/**
 * @brief Compute linear-chain crf coefficients 
 *
 */
CREATE FUNCTION MADLIB_SCHEMA.lincrf(
    "source" VARCHAR,
    "featureColumn" VARCHAR,
    "featureSize" VARCHAR,
    "tagSize" INTEGER,
    "maxNumIterations" INTEGER /*+ DEFAULT 20 */,
    "precision" DOUBLE PRECISION /*+ DEFAULT 0.0001 */)
RETURNS MADLIB_SCHEMA.lincrf_result AS $$
DECLARE
    theIteration INTEGER;
    theResult MADLIB_SCHEMA.lincrf_result;
BEGIN
    theIteration := (
        SELECT MADLIB_SCHEMA.compute_lincrf($1, $2, $3, $4, $5, $6)
    );
    EXECUTE
        $sql$
        SELECT (result).*
        FROM (
              SELECT MADLIB_SCHEMA.internal_lincrf_lbfgs_result(_madlib_state) AS result
              FROM   _madlib_iterative_alg
              WHERE  _madlib_iteration = $sql$ || theIteration || $sql$
             ) subq
        $sql$
        INTO theResult;
    -- The number of iterations are not updated in the C++ code. We do it here.
    IF NOT (theResult IS NULL) THEN
        theResult.num_iterations = theIteration;
    END IF;
    RETURN theResult;
END;
$$ LANGUAGE plpgsql VOLATILE;


CREATE FUNCTION MADLIB_SCHEMA.lincrf(
    "source" VARCHAR,
    "featureColumnn" VARCHAR,
    "featureSize" VARCHAR,
    "tagSize" INTEGER)
RETURNS MADLIB_SCHEMA.lincrf_result AS
$$SELECT MADLIB_SCHEMA.lincrf($1, $2, $3, $4, 20, 0.0001);$$
LANGUAGE sql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.lincrf(
    "source" VARCHAR,
    "featureColumnn" VARCHAR,
    "featureSize" VARCHAR,
    "tagSize" INTEGER,
    "maxNumIterations" INTEGER)
RETURNS MADLIB_SCHEMA.lincrf_result AS
$$SELECT MADLIB_SCHEMA.lincrf($1, $2, $3, $4, $5, 0.0001);$$
LANGUAGE sql VOLATILE;
