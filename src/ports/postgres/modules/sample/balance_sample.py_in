# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file EXCEPT in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from enum import Enum
import math
import re
from collections import defaultdict
from fractions import Fraction

if __name__ != "__main__":
    import plpy
    from utilities.control import MinWarning
    from utilities.utilities import _assert
    from utilities.utilities import py_list_to_sql_string
    from utilities.utilities import unique_string
    from utilities.validate_args import columns_exist_in_table
    from utilities.validate_args import get_cols
    from utilities.validate_args import table_exists
    from utilities.validate_args import table_is_empty
else:
    # FIXME: repeating a function from utilities that is needed by the unit test.
    # This should be removed once a unittest framework in used for testing.
    import random
    import time

    def unique_string(desp='', **kwargs):
        """
        Generate random remporary names for temp table and other names.
        It has a SQL interface so both SQL and Python functions can call it.
        """
        r1 = random.randint(1, 100000000)
        r2 = int(time.time())
        r3 = int(time.time()) % random.randint(1, 100000000)
        u_string = "__madlib_temp_" + desp + str(r1) + "_" + str(r2) + "_" + str(r3) + "__"
        return u_string
# ------------------------------------------------------------------------------

# m4_changequote(`<!', `!>')

UNIFORM = 'uniform'
UNDERSAMPLE = 'undersample'
OVERSAMPLE = 'oversample'
NOSAMPLE = 'nosample'

NEW_COLUMN_ID = '__madlib_id__'

def _get_sampling_strategy(sampling_strategy_str, supported_strategies, default=UNIFORM):
    if not sampling_strategy_str:
        sampling_strategy_str = default
    else:
        if len(sampling_strategy_str) < 3:
            # Require at least 3 characters since UNIFORM and UNDERSAMPLE have
            # common prefix substring
            plpy.error("Sample: Invalid class_sizes parameter")

        if not supported_strategies:
            supported_strategies = [UNIFORM, UNDERSAMPLE, OVERSAMPLE]
        try:
            # allow user to specify a prefix substring of
            # supported strategies.
            sampling_strategy_str = next(x for x in supported_strategies
                                         if x.startswith(sampling_strategy_str))
        except StopIteration:
            # next() returns a StopIteration if no element found
            plpy.error("Sample: Invalid class_sizes parameter: "
                       "{0}. Supported class_size parameters are ({1})"
                       .format(sampling_strategy_str, ','.join(sorted(supported_strategies))))
    return sampling_strategy_str
# ------------------------------------------------------------------------------


def _choose_strategy(actual_count, desired_count):
    """ Choose sampling strategy by comparing actual and desired sample counts

    @param actual_count: Actual number of samples for some level
    @param desired_count: Desired number of sample for the level
    @returns:
        Str. Sampling strategy string (either UNDERSAMPlE or OVERSAMPLE)
    """
    # OVERSAMPLE when the actual count is less than the desired count
    # UNDERSAMPLE when the actual count is more than the desired count

    # If the actual count for a class level is the same as desired count, then
    # we could potentially return the input rows as is.  This, however,
    # precludes the case of bootstrapping (i.e. returning same  number of rows
    # but after sampling with replacement).  Hence, we treat the actual=desired
    # as UNDERSAMPLE.  It's specifically set to UNDERSAMPLE since it provides
    # both 'with' and 'without' replacement  (OVERSAMPLE is always with
    # replacement and NOSAMPLE is always without replacement)
    if actual_count < desired_count:
        return OVERSAMPLE
    else:
        return UNDERSAMPLE
# -------------------------------------------------------------------------


def _get_target_level_counts(sampling_strategy_str, desired_level_counts,
                             actual_level_counts, output_table_size):
    """
    @param sampling_strategy_str: one of [UNIFORM, UNDERSAMPLE, OVERSAMPLE, None].
                               This is `None` only if this is user-defined, i.e.,
                               a comma separated list of class levels and number of
                               rows desired pairs.
    @param desired_level_counts: Dict that is defined and populated only when
                                    sampling_strategy_str is None.
    @param actual_level_counts: Dict of various class levels and number of rows
                                  in each of them in the input table
    @param output_table_size: Size of the desired output table (NULL or Integer)
    """
    target_level_counts = {}
    if not sampling_strategy_str:
        # This case implies user has provided a desired count for one or more
        # levels. Counts for the rest of the levels depend on `output_table_size`.
        #   if `output_table_size` = NULL, unspecified level counts remain as is
        #   if `output_table_size` = <Integer>, divide remaining row count
        #                             uniformly among unspecified level counts
        for each_level, desired_count in desired_level_counts.items():
            sample_strategy = _choose_strategy(actual_level_counts[each_level],
                                               desired_count)
            target_level_counts[each_level] = (desired_count, sample_strategy)

        remaining_levels = (set(actual_level_counts.keys()) -
                            set(desired_level_counts.keys()))
        if output_table_size:
            # Uniformly distribute across the remaining class levels
            remaining_rows = output_table_size - sum(desired_level_counts.values())
            if remaining_rows > 0:
                rows_per_level = math.ceil(float(remaining_rows) /
                                           len(remaining_levels))
                for each_level in remaining_levels:
                    sample_strategy = _choose_strategy(
                        actual_level_counts[each_level], rows_per_level)
                    target_level_counts[each_level] = (rows_per_level,
                                                       sample_strategy)
        else:
            # When output_table_size is unspecified, rows from the input table
            # are sampled as is for remaining class levels. This is same as the
            # NOSAMPLE strategy.
            for each_level in remaining_levels:
                target_level_counts[each_level] = (actual_level_counts[each_level], NOSAMPLE)
    else:
        def ceil_of_mean(numbers):
            return math.ceil(float(sum(numbers)) / max(len(numbers), 1))

        # UNIFORM: Ensure all level counts are same (size determined by output_table_size)
        # UNDERSAMPLE: Ensure all level counts are same as the minimum count
        # OVERSAMPLE: Ensure all level counts are same as the maximum count
        size_function = {UNDERSAMPLE: min,
                         OVERSAMPLE: max,
                         UNIFORM: ceil_of_mean
                        }[sampling_strategy_str]
        if sampling_strategy_str == UNIFORM and output_table_size:
            # Ignore actual counts for computing target sizes
            # if output_table_size is specified
            target_size_per_level = math.ceil(float(output_table_size) /
                                              len(actual_level_counts))
        else:
            target_size_per_level = size_function(actual_level_counts.values())
        for each_level, actual_count in actual_level_counts.items():
            sample_strategy = _choose_strategy(actual_count, target_size_per_level)
            target_level_counts[each_level] = (target_size_per_level,
                                               sample_strategy)
    return target_level_counts

# -------------------------------------------------------------------------

def _get_sampling_strategy_specific_dict(target_class_sizes):
    undersample_level_dict = {}
    oversample_level_dict = {}
    nosample_level_dict = {}
    for level, (count, strategy) in target_class_sizes.items():
        if strategy == UNDERSAMPLE:
            chosen_strategy = undersample_level_dict
        elif strategy == OVERSAMPLE:
            chosen_strategy = oversample_level_dict
        else:
            chosen_strategy = nosample_level_dict
        chosen_strategy[level] = count
    return (undersample_level_dict, oversample_level_dict, nosample_level_dict)
# ------------------------------------------------------------------------------


def _get_nosample_subquery(source_table, class_col, nosample_levels):
    subquery = """
                SELECT *
                FROM {0}
                WHERE {1} in ({2})
            """.format(source_table, class_col,
                        ','.join(map(str, nosample_levels)))
    return subquery
# ------------------------------------------------------------------------------


def _get_with_replacement_subquery(schema_madlib, source_table, source_table_columns,
                                   class_col, actual_level_counts, oversample_level_dict):
    """ Return the query for oversampling

    This function uses Poisson distribution to approximate the process of
    sampling with replacement. See section 17.3 in MADlib design doc
    (FIXME: Add more references!)

    """
    lambda_per_level = {}
    for each_level, actual_count in actual_level_counts.items():
        desired_count = oversample_level_dict[each_level][0]
        # lambda_val = int(math.ceil(float(desired_count) / actual_count))

        # sample a higher proportion that desired to ensure we get at least
        # 'desired_count' number of rows
        lambda_val = float(desired_count) / actual_count + 0.5
        lambda_per_level[each_level] = (lambda_val, desired_count)

    # lambda_per_level contains the Poisson lambda value for each level
    # Below string represents that dictionary in a table format
    # eg. if lambda_per_level = {'a': 5, 'b': 4, 'c': 10}
    #     then lambda_per_level_str = "VALUES ('a', 5), ('b': 4), ('c': 10)"
    # This allows joining the source table with this table-like format.
    lambda_per_level_str = "VALUES " + \
        ','.join(map(str, [(k, v[0], v[1]) for k, v in lambda_per_level.items()]))

    count_name = unique_string()
    poisson_lambda = unique_string()
    class_col_tmp = unique_string()
    row_number_col = unique_string()
    desired_count_col = unique_string()

    oversample_levels = ','.join(oversample_level_dict.keys())
    subquery = """
        SELECT {source_table_columns}
        FROM (
            SELECT {source_table_columns},
                   row_number() OVER (PARTITION BY {class_col}) AS {row_number_col},
                   {desired_count_col}
            FROM (
                SELECT {source_table_columns},
                       generate_series(1, {schema_madlib}.poisson_random({poisson_lambda}))
                            AS {count_name},
                       {desired_count_col}
                FROM
                    {source_table} s,
                    ({lambda_per_level_str})
                        q({class_col_tmp}, {poisson_lambda}, {desired_count_col})
                WHERE {class_col}::text = {class_col_tmp} AND
                      {class_col} IN ({oversample_levels})
            ) q2
        ) q3
        WHERE {row_number_col} <= {desired_count_col}
        """.format(**locals())
    return subquery
# ------------------------------------------------------------------------------


def balance_sample(schema_madlib, source_table, output_table, class_col,
                   class_sizes, output_table_size, grouping_cols,
                   with_replacement, **kwargs):

    """
    Balance sampling function
    Args:
        @param source_table       Input table name.
        @param output_table       Output table name.
        @param class_col          Name of the column containing the class to be
                                  balanced.
        @param class_sizes        Parameter to define the size of the different
                                  class values.
        @param output_table_size  Desired size of the output data set.
        @param grouping_cols      The columns that define the grouping.
        @param with_replacement   The sampling method.

    """
    with MinWarning("warning"):

        desired_sample_per_class = unique_string(desp='desired_sample_per_class')
        desired_counts = unique_string(desp='desired_counts')

        _validate_strs(source_table, output_table, class_col, class_sizes,
                       output_table_size, grouping_cols)

        actual_level_counts = _get_frequency_distribution(source_table, class_col)
        # class_sizes can be of two forms:
        #   1. A string describing sampling strategy (as described in _get_sampling_strategy)
        #       In this case, 'sampling_strategy_str' is set to one of [UNIFORM, UNDERSAMPLE, OVERSAMPLE]
        #   2. Class sizes for all (or a subset) of the class levels
        #       In this case, sampling_strategy_str = None and parsed_class_sizes
        #       is used for the sampling.
        parsed_class_sizes = extract_keyvalue_params(class_sizes)
        if not parsed_class_sizes:
            sampling_strategy_str = _get_sampling_strategy(class_sizes)
        else:
            sampling_strategy_str = None
            try:
                all_levels = actual_level_counts.keys()
                for each_level, each_class_size in parsed_class_sizes.items():
                    each_level = each_level.strip()
                    if each_level not in all_levels:
                        plpy.error("Sample: Invalid class value specified ({0})".
                                format(each_level))
                    each_class_size = int(each_class_size)
                    if each_class_size < 0:
                        plpy.error("Sample: Class size has to be positive")
                    parsed_class_sizes[each_level] = each_class_size

            except TypeError:
                plpy.error("Sample: Invalid value for class_sizes ({0})".
                           format(class_sizes))

        # Get the number of rows to be sampled for each class level, based on
        # the input table, class_sizes, and output_table_size params. This also
        # includes info about the resulting sampling strategy, i.e., one of
        # UNDERSAMPLE, OVERSAMPLE, or NOSAMPLE for each level.
        target_class_sizes = _get_target_level_counts(sampling_strategy_str,
                                                     parsed_class_sizes,
                                                     actual_level_counts,
                                                     output_table_size)

        undersample_level_dict, oversample_level_dict, nosample_level_dict = \
            _get_sampling_strategy_specific_dict(target_class_sizes)

        nosample_subquery = _get_nosample_subquery(
            source_table, class_col, nosample_level_dict.keys())
        oversample_subquery = _get_with_replacement_subquery(
            source_table, class_col, oversample_level_dict)
        if with_replacement:
            undersample_subquery = _get_with_replacement_subquery(
                source_table, class_col, undersample_level_dict)
        else:
            undersample_subquery = _get_without_replacement_subquery(
                source_table, class_col, undersample_level_dict)

        # ---------------------- REFACTORED TILL HERE -----------------------

        source_table_columns = ','.join(get_cols(source_table))
        if class_sizes.lower() == 'undersample' and not with_replacement:
            """
                Random undersample without replacement.
                Randomly order the rows and give a unique (per class)
                identifier to each one.
                Select rows that have identifiers under the target limit.
            """
            _undersampling_with_no_replacement(source_table, output_table,
                class_col, class_sizes, output_table_size, grouping_cols,
                with_replacement, actual_level_counts, source_table_columns)

            _delete_temp_views(temp_views)
            return

        """
            Create views for true and desired sample sizes of classes
        """
        """
            include_unsampled_classes tracks if unsampled classes are desired
            or not. include_unsampled_classes is always true in output_table_size
            Null cases but changes given values of desired sample class sizes in
            comma-delimited classsize paramter.
        """
        include_unsampled_classes = True
        sampling_with_comma_delimited_class_sizes = class_sizes.find('=') > 0

        if sampling_with_comma_delimited_class_sizes:
            """
                Compute sample sizes based on
                comma-delimited list of class_sizes
                and/or output_table_size
            """
            class_sizes, include_unsampled_classes = _validate_format_and_values(
                class_sizes, source_table, class_col, output_table_size,
                actual_level_counts, include_unsampled_classes)

            """
                 Only valid condition for sampling is desired_sample_sizes <=
                 output_table_size
            """
            temp_views.extend(_create_desired_and_actual_sampling_views(
                actual_level_counts, desired_sample_per_class, desired_counts,
                source_table, output_table, class_col,
                class_sizes, output_table_size, include_unsampled_classes))

        if class_sizes.lower() == 'uniform':
            """
                Compute sample sizes based on
                uniform distribution of class sizes
            """
            temp_views.extend(_compute_uniform_class_sizes(
                actual_level_counts, desired_sample_per_class, desired_counts,
                source_table, output_table, class_col, class_sizes,
                output_table_size))

        oversampling_specific_classes = False
        desired_undersample_class_sizes = defaultdict(str)

        if sampling_with_comma_delimited_class_sizes or class_sizes.lower() == 'uniform':

            oversampling_specific_classes = plpy.execute("""
                SELECT * FROM {desired_sample_per_class}
                WHERE category = 'oversample'
                """.format(**locals())).nrows() > 0
            if oversampling_specific_classes:
                with_replacement = True

            undersampling_res = plpy.execute("""
                SELECT array_agg(classes::text || '=' || sample_class_size::text)
                        as undersample_set FROM {desired_sample_per_class}
                WHERE category = 'undersample'
                """.format(**locals()))
            if undersampling_res.nrows() > 0 and undersampling_res[0]['undersample_set'] is not None:
                for val in undersampling_res[0]['undersample_set']:
                    desired_undersample_class_sizes[val.split('=')[0]] = val.split('=')[1]

        isetaflag = False

        if class_sizes.lower() == 'oversample':
            """
                oversampling with replacement
            """
            with_replacement = True
            func_name = 'max'
        elif class_sizes.lower() == 'undersample' and with_replacement:
            """
                Undersampling with replacement.
            """
            func_name = 'min'
        elif class_sizes.lower() == 'uniform':
            # oversampling_specific_classes = True
            isetaflag = True


        if with_replacement:
            """
                Random sample with replacement.
                Undersample will have func_name set to min
                Oversample will have func_name set to max.
            """
            """
                Create row identifiers for each row wrt the class
            """
            classwise_row_numbering_sql = """
                SELECT
                    *,
                    row_number() OVER(PARTITION BY {class_col})
                    AS __row_no
                FROM
                    {source_table}
                """.format(**locals())
            if oversampling_specific_classes:
                select_oversample_classes = """ WHERE {class_col}::text in
                            (SELECT classes
                            FROM {desired_sample_per_class}
                            WHERE (category like 'oversample'))
                """.format(**locals())
                classwise_row_numbering_sql += select_oversample_classes
            plpy.info("Printing 111111 classwise_row_numbering_sql")
            r = plpy.execute(classwise_row_numbering_sql)
            s = '\n'.join([str(row['gr1'])+', '+str(row['__row_no']) for row in r])
            plpy.info(s)
            """
                Create independent random values
                for each class that has a different row count than the target
            """
            if not isetaflag:
                if oversampling_specific_classes:
                    # plpy.info("I am in IF with ")
                    # plpy.info("{0}".format(func_name))
                    random_targetclass_size_sample_number_gen_sql = """
                    SELECT
                        {desired_sample_per_class}.classes,
                        generate_series(1, sample_class_size::int) AS _i,
                        ((random()*({actual_level_counts}.class_count-1)+1)::int)
                        AS __row_no
                    FROM
                        {actual_level_counts},
                        {desired_sample_per_class}
                    WHERE
                    {desired_sample_per_class}.classes = {actual_level_counts}.classes
                    AND (category like 'oversample')
                    """.format(**locals())
                    plpy.info("THAT 2222222 random_targetclass_size_sample_number_gen_sql")
                    # plpy.info(random_targetclass_size_sample_number_gen_sql)
                    r = plpy.execute(random_targetclass_size_sample_number_gen_sql)
                    s = '\n'.join([str(row['__row_no'])+', '+row['classes'] for row in r])
                    plpy.info(s)
                else:
                    # plpy.info("I am in ELSE with")
                    # plpy.info("{0}".format(func_name))
                    random_targetclass_size_sample_number_gen_sql = """
                    SELECT
                        classes,
                        generate_series(1, target_class_size::int) AS _i,
                        ((random()*({actual_level_counts}.class_count-1)+1)::int)
                        AS __row_no
                    FROM
                        (SELECT
                            {func_name}(class_count) AS target_class_size
                        FROM {actual_level_counts})
                            AS foo,
                            {actual_level_counts}
                        WHERE {actual_level_counts}.class_count != target_class_size
                    """.format(**locals())

            """
                Match random values with the row identifiers
            """
            sample_otherclass_set = """
                SELECT
                     {source_table_columns}
                FROM
                    ({classwise_row_numbering_sql}) AS f1
                RIGHT JOIN
                    ({random_targetclass_size_sample_number_gen_sql}) AS
                        f2
                ON (f1.__row_no = f2.__row_no) AND
                (f1.{class_col}::text = f2.classes)
                """.format(**locals())
            plpy.info("Printing 3333333 sample_otherclass_set")
            r = plpy.execute(sample_otherclass_set)
            s = '\n'.join([str(row['gr1']) for row in r])
            plpy.info(s)

            if not oversampling_specific_classes:
                """
                    Find classes with target number of rows
                """
                targetclass_set = """
                    SELECT
                        {source_table_columns}
                    FROM {source_table}
                    WHERE {class_col}::text IN
                        (SELECT
                            classes AS target_class
                         FROM {actual_level_counts}
                         WHERE class_count in
                            (SELECT {func_name}(class_count) FROM {actual_level_counts}))
                    """.format(**locals())

                """
                    Combine target and other sampled classes
                """
                output_sql = """
                    CREATE TABLE {output_table} AS (
                        SELECT {source_table_columns}
                        FROM
                            ({targetclass_set}) AS a
                        UNION ALL
                            ({sample_otherclass_set}))
                    """.format(**locals())
                plpy.execute(output_sql)

                _delete_temp_views(temp_views)
                return

        """
            Unsampled classes
        """
        nosample_classset_sql = """
            SELECT
                {source_table_columns}
            FROM {source_table}
            WHERE {class_col}::text IN
                (SELECT
                    classes
                 FROM {desired_sample_per_class}
                 WHERE category like 'nosample')
                    """.format(**locals())
        """
            Union all Undersampled classes
        """
        undersampling_classset_sql = ''
        plpy.info("desired_undersample_class_sizes = {0}".format(desired_undersample_class_sizes))
        if len(desired_undersample_class_sizes) > 0:
            undersampling_classset_sql = ' UNION ALL'.join("""
                (SELECT {source_table_columns}
                FROM {source_table}
                WHERE {class_col} = '{clas}'
                ORDER BY random()
                LIMIT {limit_bound})
                """.format(source_table_columns=source_table_columns,
                            source_table=source_table,
                            class_col=class_col,
                            limit_bound=clas_limit,
                            clas=clas) for clas, clas_limit in
                            desired_undersample_class_sizes.iteritems())
            undersampling_classset_sql = ' UNION ALL ' + undersampling_classset_sql

        """
            Union all Oversampled classes
        """
        oversampling_specific_classes_classset_sql = ''
        if oversampling_specific_classes:
            oversampling_specific_classes_classset_sql = """
                    UNION ALL
                        ({sample_otherclass_set})
                        """.format(**locals())

        if (oversampling_specific_classes or len(desired_undersample_class_sizes) > 0):
            """
                Combine all sampled and/or unsampled classes
            """
            if not include_unsampled_classes:
                nosample_classset_sql.replace('nosample', '')

            output_sql = """
                CREATE TABLE {output_table} AS (
                    SELECT {source_table_columns}
                    FROM
                        ({nosample_classset_sql}) AS a
                    {oversampling_specific_classes_classset_sql}
                    {undersampling_classset_sql})
                """.format(**locals())

            plpy.execute(output_sql)

        _delete_temp_views(temp_views)
    return

"""
    Delete all temp views
"""
def _delete_temp_views(temp_views):
    for temp_view in temp_views:
            plpy.execute("DROP VIEW IF EXISTS {0} cascade".format(temp_view))
    return

"""
    Random undersample without replacement.
"""
def _undersampling_with_no_replacement(source_table, output_table, class_col,
        class_sizes, output_table_size, grouping_cols, with_replacement,
        actual_level_counts, source_table_columns):

    distinct_class_labels = plpy.execute("""
        SELECT array_agg(DISTINCT {class_col}::text) AS labels
        FROM {source_table}
        """.format(**locals()))[0]['labels']

    limit_bound = plpy.execute("""
        SELECT MIN(class_count)::int AS min
        FROM {actual_level_counts}""".format(**locals()))[0]['min']

    minority_class = plpy.execute("""
        SELECT array_agg(classes::text) as minority_class
        FROM {actual_level_counts}
        WHERE class_count = {limit_bound}
        """.format(**locals()))[0]['minority_class']

    distinct_class_labels = [cl for cl in distinct_class_labels
                                if cl not in minority_class]

    foo_table = unique_string(desp='foo')

    select_union_qry = ' UNION '.join("""
        (SELECT {source_table_columns}
        FROM {source_table}
        WHERE {class_col}::text = '{val}'
        ORDER BY random()
        LIMIT {limit_bound})
        """.format(source_table_columns=source_table_columns,
                    source_table=source_table,
                    class_col=class_col,
                    limit_bound=limit_bound,
                    val=val) for val in distinct_class_labels)

    min_class_tuple = "('" + "','".join([str(a) for a in minority_class]) + "')"

    select_minority_class_qry = """ UNION
        SELECT {source_table_columns}
        FROM {source_table}
        WHERE {class_col} IN {min_class_tuple} """.format(**locals())

    output_sql = """
        CREATE TABLE {output_table} AS (
            {select_union_qry}
            {select_minority_class_qry} )""".format(**locals())
    plpy.execute(output_sql)

"""
    Captures cases where classes are specified multiple time in comma-delimited
    string. e.g. class_sizes = '5:6,5:4'
"""
class UniqueDict(dict):
    def __setitem__(self, classkey, class_size):
        if classkey not in self:
            """
             float(class_size).is_integer() ensures only whole numbers are added as
             class's sample size
            """
            if (class_size > 0.0 or class_size < 1.0) or (class_size >= 1.0 and \
            float(class_size).is_integer()):
                dict.__setitem__(self, classkey, class_size)
            else:
                plpy.error("""Sample: Sample size should be a fraction between
                    (0.0,1.0) or a whole number greater than 1""")
        else:
            plpy.error("Sample: Repeated classes in class_sizes")

"""
    Check if the class sizes (passed as strings) are alphanumeric, float or whole numbers.
    Error out on alphanumeric values.
    e.g. class_sizes = '3=a,5=b
    Returns type of the size as int or float.
"""
def _check_value_and_type(value):
    try:
        float(value)
    except:
        plpy.error("""Sample: Specify a valid fraction or an integer for class
            sample size.""")
    valueType = int if float(value).is_integer() else float

    if float(value) < 0:
        plpy.error("Sample: Class sample size has to be positive.")

    return valueType
"""
    Check if classes are present in class_col
"""
def _validate_classes(all_classes, source_table, class_col):

    nonexisting_classes = plpy.execute("""
            SELECT
                unnest(ARRAY[{all_classes}])
            EXCEPT
            SELECT
                distinct({class_col}::text)
            FROM {source_table}
        """.format(**locals()))

    if nonexisting_classes.nrows() > 0:
        plpy.error("""Sample: Specified classes do not exist in
            {class_col}""".format(**locals()))

"""
    Checks the format and values of classes and their respective sizes specified
    in comman-delimited string.
    1. Checks if the classes specified are present in the source table.
    2. Checks for total sample size to be between (0.0,1.0]
    3. Checks for output_table_size < total desired size of the classes
    specified in class_sizes
    4. Checks for cases when only fractions or whole numbers specified in sample
    sizes
    5. Checks for value is a whole number greater then 1
    6. Checks if same class is specified multiple times in class_sizes
    7. Checks is classes are present in class_col
"""
def _validate_format_and_values(class_sizes, source_table, class_col,
                    output_table_size, actual_level_counts, include_unsampled_classes):

    class_sizes_arr = [cls.strip() for cls in class_sizes.split(',')]
    class_sizes = ','.join(class_sizes_arr)

    cs_dict = UniqueDict(defaultdict())

    numeric_value_sum = 0
    fraction_value_sum = 0.0

    for x in class_sizes_arr:
        class_and_size = x.split('=')
        valueType = _check_value_and_type(class_and_size[1])
        fraction_value_sum += valueType(class_and_size[1]) if valueType == float else 0.0
        numeric_value_sum += valueType(class_and_size[1]) if valueType != float else 0
        cs_dict[class_and_size[0].strip()] = valueType(class_and_size[1])

    """
        Check to see if specified classes are present in the class_col
    """
    all_classes = str(cs_dict.keys())[1:-1]
    _validate_classes(all_classes, source_table, class_col)

    """
        Error out if fraction_value_sum is greater than 1.0 or when fraction sum
        is 1.0 and other classes with whole numbers as class sizes are also
        specified.
    """
    if fraction_value_sum > 1.0:
        plpy.error("Sample: Fraction sum can be at most 1.0.")
    if fraction_value_sum == 1.0 and numeric_value_sum != 0:
        plpy.error("""Sample: Cannot specify desired number of rows when sum of
            fractions specified is equal to one. """.format(**locals()))

    total_table_size = plpy.execute("""
            SELECT
                count(*) AS total
            FROM {source_table}
        """.format(**locals()))[0]['total']

    """
        Compute class sizes when no Fractions are specified in class_sizes
    """
    if Fraction(str(fraction_value_sum)) == Fraction(str(0.0)):
        if (not output_table_size):
            # Sample remaining classes uniformly
            return class_sizes, include_unsampled_classes

        if output_table_size < numeric_value_sum:
            plpy.error("""Sample: Output table size ({output_table_size})
                must be more than total specified sample size i.e.
                {numeric_value_sum}""".format(**locals()))

        if output_table_size == numeric_value_sum:
            # Do not sample other classes
            return class_sizes, not include_unsampled_classes

        # Sample remaining classes uniformly with target table size
        return class_sizes, include_unsampled_classes

    """
        Compute class sizes when only Fractions are specified in class_sizes,
        which also sum to 1.0
    """
    if Fraction(str(fraction_value_sum)) == Fraction(str(1.0)):
        # Do not sample other classes
        return _compute_class_sizes(cs_dict, total_table_size)[0], not include_unsampled_classes

    """
        Compute sample classs size when both fractions and whole numbers are mentioned in class_size comma-delimited string
    """
    if Fraction(str(fraction_value_sum)) > Fraction(str(0.0)):

        sum_remaining_class_samples = plpy.execute("""
                SELECT sum({actual_level_counts}.class_count) AS remaining_classes FROM {actual_level_counts}
                WHERE classes not IN ({all_classes})
                """.format(**locals()))
        """
            When output_table_size is Null. Use following example logic to
            compute desired sample sizes.

            Suppose male=.4,output_table_size= NULL and letâ€™s say there are 2
            other categorical values female=10M, other=1M
            Use the following logic to calculate 'computed' output_table_size x
                     .4x + 10M + 1M = x
            where x = computed output_table_size. Here x = 18.3M
        """
        if (not output_table_size):
            y = 1.0 - fraction_value_sum

            if sum_remaining_class_samples.nrows() > 0:
                numeric_value_sum += sum_remaining_class_samples[0]['remaining_classes']

            if numeric_value_sum == 0:
                # A rare case happens WHEN there is ONLY one class present in
                # class_col
                return _compute_class_sizes(cs_dict, total_table_size)[0], not include_unsampled_classes

            # Compute total_desired_sample_size as x
            x = math.ceil(float(numeric_value_sum) / y)
            class_size, _ = _compute_class_sizes(cs_dict, x)
            return class_size, include_unsampled_classes

        """
            When output_table_size is given, compute the total_desired_sample_size
            and perform checks to ensure validity of class_size with total_desired_sample_size
        """
        output_table_size = float(output_table_size)
        class_size, total_desired_sample_size = _compute_class_sizes(cs_dict, output_table_size)

        ## Cases when total desired sample size > specified output table size
        if total_desired_sample_size > output_table_size:
            plpy.error("""Sample: Output table size ({output_table_size}) must
                be more than total desired sample size i.e \
                {total_desired_sample_size}""".format(**locals()))

        if total_desired_sample_size == output_table_size:
            # Do not sample other classes
            return class_size, not include_unsampled_classes

        if total_desired_sample_size < output_table_size:
            # Sample other classes uniformly
            return class_size, include_unsampled_classes

"""
    Proportions of class sizes are multiplied by output_table_size to get
    desired whole number value for class sizes. A total_desired_size is sum of
    all whole number class sizes
"""
def _compute_class_sizes(cs_dict, x):
    class_size = ''
    total_desired_size = 0
    for clas, class_val in cs_dict.iteritems():
        if float(class_val).is_integer():
            total_desired_size += class_val
            class_size += str(clas) + '=' + str(class_val) + ','
        else:
            class_val = int(round(class_val * x, 0))
            total_desired_size += class_val
            class_size += str(clas) + '=' + str(class_val) + ','
    return class_size[:-1], total_desired_size

"""
    Create view to store class counts of classes in class_col
"""
def _get_frequency_distribution(source_table, class_col):
    query_result = plpy.execute("""
                    SELECT {class_col}::text AS classes,
                           count(*) AS class_count
                    FROM {source_table}
                    GROUP BY {class_col}
                 """.format(**locals()))
    actual_level_counts = {}
    for each_row in query_result:
        actual_level_counts[each_row['classes']] = each_row['class_count']
    return actual_level_counts

"""
    Create view desired_sample_per_class which contains the desired sampling for
    each class.
 """
def _create_desired_and_actual_sampling_views(actual_level_counts, desired_sample_per_class,
                                              desired_counts, source_table,
                                              output_table, class_col,
                                              class_sizes,output_table_size,
                                              include_unsampled_classes):

    # Split class_sizes
    if len(class_sizes.split(',')) > 1:
        values = '\',\''.join(class_sizes.split(','))
    else:
        values = class_sizes.split(',')[0]

    create_desired_counts_sql = """
        CREATE VIEW {desired_counts} AS (
        SELECT val[1]::text AS desired_classes,
               val[2]::int AS desired_values
        FROM
            (SELECT regexp_split_to_array(unnest(ARRAY['{values}']),E'=') AS val)
        AS foo
        )
    """.format(**locals())
    temp_views = [desired_counts]
    plpy.execute(create_desired_counts_sql)

    if not include_unsampled_classes:
        """
            No extra/other classes desired, other than the ones
            specified in the class_sizes parameter
        """
        desired_sample_per_class_sql = """
            CREATE VIEW {desired_sample_per_class} AS (
                SELECT
                    desired_classes AS classes,
                    desired_values::int AS sample_class_size,
                    1::int as actual_class_size,
                    CASE
                      WHEN (desired_values - class_count) = 0 THEN 'nosample'
                      WHEN (desired_values - class_count) > 0 THEN 'oversample'
                      ELSE 'undersample'
                    END AS category
            FROM
                {actual_level_counts}
                JOIN
                {desired_counts}
                ON ({actual_level_counts}.classes = {desired_counts}.desired_classes)
            )
            """.format(**locals())
    else:
        """
            If output_table_size is specified,
            uniformly sample remaining classes.
        """
        remaining_class_samples = ''
        if output_table_size:

            remaining_class_samples = _sample_remaining_classes_uniformly_per_output_table_size(
                actual_level_counts, desired_counts, output_table_size)

            desired_sample_per_class_sql = """
            CREATE VIEW {desired_sample_per_class} AS (
                SELECT
                        classes,
                        desired_values::int AS sample_class_size,
                        class_count AS actual_class_size,
                        CASE
                          WHEN (desired_values - class_count) = 0 THEN 'nosample'
                          WHEN (desired_values - class_count) > 0 THEN 'oversample'
                          ELSE 'undersample'
                        END AS category
                FROM (
                    SELECT
                            classes,
                            CASE (SELECT 1 WHERE desired_values is NULL)
                                WHEN 1 THEN extra_values
                                ELSE desired_values
                            END AS desired_values,
                            class_count
                    FROM
                        {actual_level_counts}
                        LEFT JOIN
                        {desired_counts}
                        ON ({actual_level_counts}.classes = {desired_counts}.desired_classes)
                        LEFT JOIN
                        {remaining_class_samples}
                        ON ({actual_level_counts}.classes = {remaining_class_samples}.extra_classes)
                        ) AS foo
                )
            """.format(**locals())
        else:
            """
                If output_table_size is not specified,
                return remaining classes as is.
            """
            desired_sample_per_class_sql = """
                CREATE VIEW {desired_sample_per_class} AS (
                    SELECT
                            classes,
                            desired_values::int AS sample_class_size,
                            class_count as actual_class_size,
                            CASE
                              WHEN (desired_values - class_count) = 0 THEN 'nosample'
                              WHEN (desired_values - class_count) > 0 THEN 'oversample'
                              ELSE 'undersample'
                            END AS category
                    FROM (
                        SELECT
                                classes,
                                CASE (SELECT 1 WHERE desired_values is NULL)
                                    WHEN 1 THEN class_count
                                    ELSE desired_values
                                END AS desired_values,
                                class_count
                        FROM
                            {actual_level_counts}
                             LEFT JOIN
                            {desired_counts}
                            ON ({actual_level_counts}.classes = {desired_counts}.desired_classes)
                            ) AS foo
                    )
                """.format(**locals())
        if remaining_class_samples:
            temp_views.append(remaining_class_samples)

    plpy.execute(desired_sample_per_class_sql)
    temp_views.append(desired_sample_per_class)
    return temp_views

"""
    Sample the remaining classes in output_table_size - (total calculated
    class sizes).
"""
def _sample_remaining_classes_uniformly_per_output_table_size(actual_level_counts,
                                                              desired_counts,
                                                              output_table_size):

    remaining_class_samples = unique_string(desp='remaining_class_samples')
    foo_table = unique_string(desp='foo')
    remaining_class_samples_sql = """
        CREATE VIEW {remaining_class_samples} as (
            SELECT
                extra_classes,
                ceil(((desired_total_size - desired_total_class_size)::FLOAT8)/((total_classes - desired_distinct_class_count)::FLOAT8))
                AS extra_values
            FROM
                (SELECT
                    {output_table_size}::float8 AS desired_total_size)
                        AS constant_output_table_size,
                (SELECT
                    sum(desired_values) AS desired_total_class_size,
                    count(*) AS desired_distinct_class_count
                FROM {desired_counts})
                        AS user_desired_class_sizes,
                (SELECT
                    count(*) AS total_classes
                FROM {actual_level_counts})
                        AS actual_table_frequencies,
                (SELECT
                    classes AS extra_classes
                FROM
                    (SELECT
                        classes
                    FROM {actual_level_counts}
                        EXCEPT
                    SELECT
                        desired_classes
                    FROM {desired_counts}
                    ) AS {foo_table})
                        AS remaining_classes)
        """.format(**locals())

    plpy.execute(remaining_class_samples_sql)
    return remaining_class_samples

"""
    Calculate uniform class sizes per class
"""
def _compute_uniform_class_sizes(actual_level_counts, desired_sample_per_class,
                                desired_counts, source_table, output_table,
                                class_col, class_sizes, output_table_size):

    calculated_sample_per_class = unique_string(desp='calculated_sample_per_class')
    foo_table = unique_string(desp='foo')

    output_table_sql = ''
    if output_table_size:
        output_table_sql = """
                (SELECT {output_table_size}::float8 as a) as {foo_table}
        """.format(**locals())
    else:
        output_table_sql = """
                (SELECT count(*)::float8 as a FROM {source_table}) as {foo_table}
        """.format(**locals())

    calculated_sample_per_class_sql = """
        CREATE VIEW {calculated_sample_per_class}  AS (
            SELECT
                ceil(a/b) AS sample_size
            FROM
                {output_table_sql},
                (SELECT count(distinct({class_col}))::float8 b
                 FROM {source_table}) AS bar
        )
        """.format(**locals())
    plpy.execute(calculated_sample_per_class_sql)

    desired_sample_per_class_sql = """
        CREATE VIEW {desired_sample_per_class} AS (
            SELECT
                classes,
                uniform_sample_size AS sample_class_size,
                class_count AS actual_class_size,
                CASE
                    WHEN (uniform_sample_size - class_count) = 0 THEN 'nosample'
                    WHEN (uniform_sample_size - class_count) > 0 THEN 'oversample'
                    ELSE 'undersample'
                END AS category
            FROM
                (SELECT
                        classes,
                        sample_size AS uniform_sample_size,
                        class_count
                  FROM
                      {actual_level_counts},
                      {calculated_sample_per_class}
                ) AS foo)
        """.format(**locals())
    plpy.info(desired_sample_per_class_sql)
    plpy.execute(desired_sample_per_class_sql)

    temp_views = [calculated_sample_per_class, desired_sample_per_class, foo_table]

    return temp_views


def _validate_strs (source_table, output_table, class_col, class_sizes,
                    output_table_size, grouping_cols):

    _assert(source_table and table_exists(source_table),
        "Sample: Source table ({source_table}) does not exist.".format(**locals()))
    _assert(not table_is_empty(source_table),
        "Sample: Source table ({source_table}) is empty.".format(**locals()))

    _assert(output_table,
        "Sample: Output table name is missing.".format(**locals()))
    _assert(not table_exists(output_table),
        "Sample: Output table ({output_table}) already exists.".format(**locals()))

    _assert(class_col,
        "Sample: Class column name is missing.".format(**locals()))
    _assert(columns_exist_in_table(source_table, [class_col]),
        ("""Sample: Class column ({class_col}) does not exist in"""+
            """ table ({source_table}).""").format(**locals()))

    _assert(not columns_exist_in_table(source_table, [NEW_COLUMN_ID]),
        ("""Sample: Please ensure the source table ({0})"""+
            """ does not contain a column named {1}""").format(source_table, NEW_COLUMN_ID))

    _assert(class_sizes in (UNIFORM, UNDERSAMPLE, OVERSAMPLE)
            or (class_sizes.find('=') > 0),
            "Sample: Invalid class size ({class_sizes}).".format(**locals()))

    _assert(not(class_sizes.lower() == 'oversample' and output_table_size),
        "Sample: Cannot set output_table_size with oversampling.")

    _assert(not(class_sizes.lower() == 'undersample' and output_table_size),
        "Sample: Cannot set output_table_size with undersampling.")

    _assert((not output_table_size) or (output_table_size > 0),
        "Sample: Invalid output table size ({output_table_size}).".format(
            **locals()))

    _assert(grouping_cols is None,
        "grouping_cols is not supported at the moment."
        .format(**locals()))

    return

def balance_sample_help(schema_madlib, message, **kwargs):
    """
    Help function for balance_sample

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Given a table with varying set of records for each class label,
this function will create an output table with a varying types (by
default: uniform) of sampling distributions of each class label. It is
possible to use with or without replacement sampling methods, specify
different proportions of each class, multiple grouping columns and/or
output table size.

For more details on function usage:
    SELECT {schema_madlib}.balance_sample('usage');
    SELECT {schema_madlib}.balance_sample('example');
            """
    elif message.lower() in ['usage', 'help', '?']:
        help_string = """

Given a table, stratified sampling returns a proportion of records for
each group (strata). It is possible to use with or without replacement
sampling methods, specify a set of target columns, and assume the
whole table is a single strata.

----------------------------------------------------------------------------
                            USAGE
----------------------------------------------------------------------------

 SELECT {schema_madlib}.balance_sample(
    source_table      TEXT,     -- Input table name.
    output_table      TEXT,     -- Output table name.
    class_col         TEXT,     -- Name of column containing the class to be
                                -- balanced.
    class_size        TEXT,     -- (Default: NULL) Parameter to define the size
                                -- of the different class values.
    output_table_size INTEGER,  -- (Default: NULL) Desired size of the output
                                -- data set.
    grouping_cols     TEXT,     -- (Default: NULL) The columns columns that
                                -- defines the grouping.
    with_replacement  BOOLEAN   -- (Default: FALSE) The sampling method.

If class_size is NULL, the source table is uniformly sampled.

If output_table_size is NULL, the resulting output table size will depend on
the settings for the â€˜class_sizeâ€™ parameter. It is ignored if â€˜class_sizeâ€™
parameter is set to either â€˜oversampleâ€™ or â€˜undersampleâ€™.

If grouping_cols is NULL, the whole table is treated as a single group and
sampled accordingly.

If with_replacement is TRUE, each sample is independent (the same row may
be selected in the sample set more than once). Else (if with_replacement
is FALSE), a row can be selected at most once.
);
"""
    elif message.lower() in ("example", "examples"):
        help_string = """
----------------------------------------------------------------------------
                                EXAMPLES
----------------------------------------------------------------------------

-- Create an input table
DROP TABLE IF EXISTS test;

CREATE TABLE test(
    id1 INTEGER,
    id2 INTEGER,
    gr1 INTEGER,
    gr2 INTEGER
);

INSERT INTO test VALUES
(1,0,1,1),
(2,0,1,1),
(3,0,1,1),
(4,0,1,1),
(5,0,1,1),
(6,0,1,1),
(7,0,1,1),
(8,0,1,1),
(9,0,1,1),
(9,0,1,1),
(9,0,1,1),
(9,0,1,1),
(0,1,1,2),
(0,2,1,2),
(0,3,1,2),
(0,4,1,2),
(0,5,1,2),
(0,6,1,2),
(10,10,2,2),
(20,20,2,2),
(30,30,2,2),
(40,40,2,2),
(50,50,2,2),
(60,60,2,2),
(70,70,2,2)
;

-- Sample without replacement
DROP TABLE IF EXISTS out;
SELECT balance_sample('test', 'out', 'gr1', 'undersample', NULL, NULL, FALSE);
SELECT * FROM out;

--- Sample with replacement
DROP TABLE IF EXISTS out_sr2;
SELECT balance_sample('test', 'out', 'gr1', 'undersample', NULL, NULL, TRUE);
SELECT * FROM out;
"""
    else:
        help_string = "No such option. Use {schema_madlib}.graph_sssp()"

    return help_string.format(schema_madlib=schema_madlib)

import unittest

class UtilitiesTestCase(unittest.TestCase):
    """
        Comment "import plpy" and replace plpy.error calls with appropriate
        Python Exceptions to successfully run the test cases
    """
    def setUp(self):
        self.input_class_level_counts1 = {'a':20, 'b':30, 'c':25}
        self.level1a = 'a'
        self.level1a_cnt1 = 15
        self.level1a_cnt2 = 25
        self.level1a_cnt3 = 20

        self.sampling_strategy_str0 = ''
        self.sampling_strategy_str1 = 'uniform'
        self.sampling_strategy_str2 = 'oversample'
        self.sampling_strategy_str3 = 'undersample'
        self.user_specified_class_size0 = ''
        self.user_specified_class_size1 = {'a':25, 'b':25}
        self.user_specified_class_size2 = {'b':25}
        self.user_specified_class_size3 = {'a':30}
        self.output_table_size1 = None
        self.output_table_size2 = 60
        # self.input_class_level_counts2 = {'a':100, 'b':100, 'c':100}


    def test__choose_strategy(self):
        self.assertEqual(UNDERSAMPLE, _choose_strategy(35, 25))
        self.assertEqual(OVERSAMPLE, _choose_strategy(15, 25))
        self.assertEqual(UNDERSAMPLE, _choose_strategy(25, 25))

    def test__get_target_level_counts(self):
        # Test cases for user defined class level samples, without output table size
        self.assertEqual({'a':(25, OVERSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(25, NOSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size1,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        self.assertEqual({'a':(20, NOSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(25, NOSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size2,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        self.assertEqual({'a':(30, OVERSAMPLE), 'b':(30, NOSAMPLE), 'c':(25, NOSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size3,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        # Test cases for user defined class level samples, with output table size
        self.assertEqual({'a':(25, OVERSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(10, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size1,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size2))
        self.assertEqual({'a':(18, UNDERSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(18, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size2,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size2))
        self.assertEqual({'a':(30, OVERSAMPLE), 'b':(15, UNDERSAMPLE), 'c':(15, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str0,
                                                  self.user_specified_class_size3,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size2))
        # Test cases for UNIFORM, OVERSAMPLE, and UNDERSAMPLE without any output table size
        self.assertEqual({'a':(25, OVERSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(25, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str1,
                                                  self.user_specified_class_size0,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        self.assertEqual({'a':(30, OVERSAMPLE), 'b':(30, UNDERSAMPLE), 'c':(30, OVERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str2,
                                                  self.user_specified_class_size0,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        self.assertEqual({'a':(20, UNDERSAMPLE), 'b':(20, UNDERSAMPLE), 'c':(20, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str3,
                                                  self.user_specified_class_size0,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size1))
        # Test cases for UNIFORM with output table size
        self.assertEqual({'a':(20, UNDERSAMPLE), 'b':(20, UNDERSAMPLE), 'c':(20, UNDERSAMPLE)},
                         _get_target_level_counts(self.sampling_strategy_str1,
                                                  self.user_specified_class_size0,
                                                  self.input_class_level_counts1,
                                                  self.output_table_size2))

    def test__get_sampling_strategy_specific_dict(self):
        # Test cases for getting sampling strategy specific counts
        target_level_counts_1 = {'a':(25, OVERSAMPLE), 'b':(25, UNDERSAMPLE), 'c':(25, NOSAMPLE) }
        target_level_counts_2 = {'a':(25, OVERSAMPLE), 'b':(25, UNDERSAMPLE)}
        target_level_counts_3 = {'a':(25, OVERSAMPLE), 'b':(25, NOSAMPLE), 'c':(25, NOSAMPLE) }
        self.assertEqual(({'b':25}, {'a':25}, {'c':25}),
                        _get_sampling_strategy_specific_dict(target_level_counts_1))
        self.assertEqual(({'b':25}, {'a':25}, {}),
                        _get_sampling_strategy_specific_dict(target_level_counts_2))
        self.assertEqual(({}, {'a':25}, {'c':25, 'b':25}),
                        _get_sampling_strategy_specific_dict(target_level_counts_3))


if __name__ == '__main__':
    unittest.main()
    # print(_get_with_replacement_subquery('madlib', 'madlibtestdata.log_ornstein_wi',
    #                                "x, y, grp_by_col",
    #                                'grp_by_col',
    #                                {'1': 119, '2': 129},
    #                                {'1': (360, OVERSAMPLE), '2': (500, OVERSAMPLE)}))
